---
title: 分析包含Read计算的单细胞RNA-seq数据
author: 
- name: Aaron T. L. Lun
  affiliation: &CRUK Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
- name: Davis J. McCarthy
  affiliation: 
  - &EMBL EMBL European Bioinformatics Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SD, United Kingdom
  - St Vincent's Institute of Medical Research, 41 Victoria Parade, Fitzroy, Victoria 3065, Australia
- name: John C. Marioni
  affiliation: 
  - *CRUK
  - *EMBL
  - Wellcome Trust Sanger Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SA, United Kingdom
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{02. Read count data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
output: 
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
bibliography: ref.bib
---

```{r style, echo=FALSE, results='hide', message=FALSE, cache=FALSE}
library(BiocStyle)
library(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE, cache=TRUE)
opts_chunk$set(fig.asp=1)
```

# 概述

在这个工作流程中，我们使用一个相对简单的数据集 [@lun2017assessing] 来介绍scRNA-seq数据分析的大部分概念。
该数据集包含两个416B细胞板（永生化小鼠骨髓祖细胞系），使用Smart-seq2s实验方法来处理 [@picelli2014fulllength]。
在文库制备之前，还将the External RNA Controls协会（ERCC）的z指定的恒定量的加标RNA添加到每个细胞的裂解物中。
然后进行进行高通量测序，并通过计数能比对到外显子区域的reads的总数来量化每个基因的表达量。
类似地，通过计算比对到加标参考序列的reads的数量，可以测量每个加标转录物的量。

每个细胞中所有基因/转录物的计数l量可以从 accession number为 [E-MTAB-5522](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-5522)中的ArrayExpress获得。
这里将会使用`r Biocpkg("BiocFileCache")`下载两个计数表（在“已处理文件”中）以及metadata数据文件。
这会将文件保存到本地缓存 (`raw_data`)中 ，并避免在已存在的情况下重新下载它们。

```{r}
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
lun.zip <- bfcrpath(bfc, 
    file.path("https://www.ebi.ac.uk/arrayexpress/files",
        "E-MTAB-5522/E-MTAB-5522.processed.1.zip"))
lun.sdrf <- bfcrpath(bfc, 
    file.path("https://www.ebi.ac.uk/arrayexpress/files",
        "E-MTAB-5522/E-MTAB-5522.sdrf.txt"))
unzip(lun.zip, exdir=tempdir())
```

<!--
We don't use a global cache to ensure that the package build is self-contained on the Bioc build system and elsewhere.
This avoids problems with cross-package behaviour.
It also ensures that a new file is downloaded at every build, which is necessary for checking that the files are current.
We avoid hosting an extra copy of everything (locally) by soft-linking raw_data to ~/.cache/BiocFileCache/.
-->

# 数据设置

## 加载计数矩阵

我们首先要将计数矩阵加载到内存中。
在这个研究中，每一个细胞板会产生一个计数矩阵。
在每个矩阵中中，每行代表内源基因或加标转录物，每列代表一个细胞。
l另外，矩阵中的每个条目中的计数表示比对到特定细胞中的特定基因/转录物的reads的数量。

```{r}
plate1 <- read.delim(file.path(tempdir(), "counts_Calero_20160113.tsv"), 
    header=TRUE, row.names=1, check.names=FALSE)
plate2 <- read.delim(file.path(tempdir(), "counts_Calero_20160325.tsv"), 
    header=TRUE, row.names=1, check.names=FALSE)

gene.lengths <- plate1$Length # 第一列是基因长度.
plate1 <- as.matrix(plate1[,-1]) # 去除基因长度那一列 (as it is not a cell).
plate2 <- as.matrix(plate2[,-1])
rbind(Plate1=dim(plate1), Plate2=dim(plate2))
```

我们将两个矩阵组合成一个对象以进行进一步处理。
但这一步是基于在确认基因排列顺序是在两个计数矩阵上是相同的，才能进行。This is done after verifying that the genes are in the same order between the two matrices.

```{r}
stopifnot(identical(rownames(plate1), rownames(plate2)))
all.counts <- cbind(plate1, plate2)
```

为方便起见，计数矩阵已经存储在`r Biocpkg("SingleCellExperiment")` 包中的 `SingleCellExperiment` 对象中。
这允许将不同类型的行和列水平的metadata与整个工作流中的同步操作的计数一起存储。

```{r}
library(SingleCellExperiment)
sce <- SingleCellExperiment(list(counts=all.counts))
rowData(sce)$GeneLength <- gene.lengths
sce
```

我们从行名中能识别对应着ERCC加标的转录本的行。
我们将此信息存储在 `SingleCellExperiment` 对象中以供以后使用。
这一步是必要的，因为加标的数据需要在下游步骤中进行特殊处理，例如标准化。

```{r}
isSpike(sce, "ERCC") <- grepl("^ERCC", rownames(sce))
summary(isSpike(sce, "ERCC"))
```

该数据集略微不同寻常，因为它包含来自另一组加标转录物的信息，即Spike-In RNA Variants（SIRV）组。
为简单起见，我们将仅在此分析中使用ERCC加标。因此，我们必须在进一步分析之前删除对应于SIRV转录本的行，这可以简单地通过对 `SingleCellExperiment` 对象进行子集化来完成。

```{r}
is.sirv <- grepl("^SIRV", rownames(sce))
sce <- sce[!is.sirv,] 
summary(is.sirv)
```

**来自作者Aaron的评价:**

- 一些特征计数工具将在计数矩阵中报告比对信息统计数据（例如，比对不上的reads数量）。
虽然这些值可用于质量控制，但如果将其错误地视为基因表达值，则会对结果产生误导。
因此，在进一步分析之前，这些值应当被移除或至少移到`colData`中。
- 在人类数据中，注意使用 `^ERCC` 正则表达式， 其中计数矩阵的行名称是基因符号。
ERCC基因家族实际上存在于人类注释文件中，如果不小心将导致基因被错误地识别为加标转录本。An 
通过使用已发表的具有标准标识符的计数矩阵（例如，Ensembl，Entrez）可以避免该问题。

## 合并基于细胞的注释

我们从`sdrf.txt` w文件中加载每个库/细胞的metadata。
这里要记得检查meta数据表的行与计数矩阵的列的顺序是否相同。
否则，将为每个细胞分配不正确的meta数据。

```{r}
metadata <- read.delim(lun.sdrf, check.names=FALSE, header=TRUE)
m <- match(colnames(sce), metadata[["Source Name"]]) # 确保顺序相同
stopifnot(all(!is.na(m))) # 确保没有丢失信息
metadata <- metadata[m,]
head(colnames(metadata))
```

我们只保留相关的meta数据信息，以避免`colData`在`SingleCellExperiment`对象中存储不必要的信息。
我们会特别地保留每个细胞的起源板 (例如 `block`) 和表型。
第二个癌基因项是相关的，因为所有细胞都含有`CBFB-MYH11`癌基因，但该癌基因的表达仅在一部分细胞中被诱导。

```{r}
colData(sce)$Plate <- factor(metadata[["Factor Value[block]"]])
pheno <- metadata[["Factor Value[phenotype]"]]
levels(pheno) <- c("induced", "control")
colData(sce)$Oncogene <- pheno
table(colData(sce)$Oncogene, colData(sce)$Plate)
```

## 整合基于基因的注释

特征计数工具通常根据Ensembl或Entrez的标准标识符报告基因。
使用这些标识符是因为它们已经被明确肯定且高度稳定。
然而，与文献中更常用的基因符号相比，它们更难被解释。
根据给定Ensembl标识符，我们使用`r Biocpkg("org.Mm.eg.db")`等注释包来获取相对应的基因符号。

```{r}
library(org.Mm.eg.db)
symb <- mapIds(org.Mm.eg.db, keys=rownames(sce), keytype="ENSEMBL", column="SYMBOL")
rowData(sce)$ENSEMBL <- rownames(sce)
rowData(sce)$SYMBOL <- symb
head(rowData(sce))
```

通常需要将行名重命名为`sce`基因符号，因为这更便于解释。
但是，这需要额外的功夫来解决丢失和重复的符号的问题。
下面的代码将使用Ensembl标识符替换缺少的符号，并使用（唯一的）Ensembl标识符连接重复的符号。

```{r}
library(scater)
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ENSEMBL, rowData(sce)$SYMBOL)
head(rownames(sce))
```

我们还使用 `r Biocpkg("TxDb.Mmusculus.UCSC.mm10.ensGene")` 包来确定每个基因的染色体位置。
这一步将在以后的分析有用，因为质控用到的度量将会从对应于线粒体基因的行来计算。

```{r}
library(TxDb.Mmusculus.UCSC.mm10.ensGene)
location <- mapIds(TxDb.Mmusculus.UCSC.mm10.ensGene, keys=rowData(sce)$ENSEMBL, 
    column="CDSCHROM", keytype="GENEID")
rowData(sce)$CHR <- location
summary(location=="chrM")
```

或者，可以使用`r Biocpkg("scater")`中的`getBMFeatureAnnos`函数将BioMart资源中的注释直接添加到对象中。
这可能比上面显示的方法更方便，但取决于与BioMart数据库的可用互联网连接。

# 对细胞的质控

## 定义质控的指标

低质量的细胞需要移除，以确保技术带来的影响不会扭曲下游分析结果
我们使用多个质控（QC）的指标:

- 文库大小定义为所有特征（即基因和加标转录本）的总计数。
细胞具有小文库意味着质量低，因为在文库制备期间RNA未被有效捕获（转化成cDNA并扩增）。
- 每个细胞中表达的特征量被定义为该单细胞所具有的非零计数的特征量。
表达基因量低的细胞通常意味着质量很差，因为细胞中含有的多样的转录本群体尚未被成功捕获。
- 比对到加标转录物的reads的比例是相对于每个细胞的文库大小计算的。该比例越高表示细胞质量差，其中内源RNA在加工过程中已经丢失（例如，由于细胞裂解或RNA降解）。
每个细胞加入相同量的加标RNA，因此加标计数的富集是内源性RNA丢失所引起的。
- 在没有加标转录物的情况下，也可以使用比对到线粒体基因组中的基因的reads的比例作为指标。
该比例高表明细胞质量差[@islam2014quantitative;@ilicic2016classification], 可能是因为穿孔细胞中细胞质RNA的丢失。
原因是线粒体比单个转录物分子大，不大可能从细胞膜的液体中逃脱。

对于每个细胞，我们使用 `r Biocpkg("scater")` 包中的`calculateQCMetrics`函数计算这些质控指标 [@mccarthy2017scater]。
这些指标存储在meta数据`SingleCellExperiment`中的行和列中，以供以后使用。
```{r}
mito <- which(rowData(sce)$CHR=="chrM")
sce <- calculateQCMetrics(sce, feature_controls=list(Mt=mito))
head(colnames(colData(sce)), 10)
```

这些指标的分布如图 \@ref(fig:qcplot416b)所示,由癌基因诱导状态和细胞起源板分层。
这一步目的是去除假定的低质量细胞，这些细胞具有小的文库，低表达特征量和高加标物（或线粒体）比例。
此类细胞可干扰下游分析，例如，通过形成不同细胞簇使结果复杂化，更难以解析。

```{r qcplot416b, fig.wide=TRUE, fig.cap="416B数据集中所有细胞的各种QC指标的分布。这包括文库大小，表达基因的数量和比对到加标转录物或线粒体基因的reads的比例。"}
sce$PlateOnco <- paste0(sce$Oncogene, ".", sce$Plate)
multiplot(
    plotColData(sce, y="total_counts", x="PlateOnco"),
    plotColData(sce, y="total_features_by_counts", x="PlateOnco"),
    plotColData(sce, y="pct_counts_ERCC", x="PlateOnco"),
    plotColData(sce, y="pct_counts_Mt", x="PlateOnco"),
    cols=2)
```

另外明白质控指标是怎样相互影响关联的的也是非常重要的 (Figure \@ref(fig:qcbiplot416b))。
通常，它们是大概一致的，比如有低总计数的细胞也将具有低数量的表达特征和高ERCC /线粒体比例。 
明显的差异可能是由细胞之间技术差异导致的批次效应产生的（见下文）又或者是由真正生物学差异导致RNA量的不同。

```{r qcbiplot416b, fig.width=10, fig.asp=0.5, fig.cap="每个QC指标与表达特征总量的比较。每个点代表416B数据集中的一个细胞。"}
par(mfrow=c(1,3))
plot(sce$total_features_by_counts, sce$total_counts/1e6, xlab="Number of expressed genes",
    ylab="Library size (millions)")
plot(sce$total_features_by_counts, sce$pct_counts_ERCC, xlab="Number of expressed genes",
    ylab="ERCC proportion (%)")
plot(sce$total_features_by_counts, sce$pct_counts_Mt, xlab="Number of expressed genes",
    ylab="Mitochondrial proportion (%)")
```

## 识别每个指标的异常值

选择这些指标的阈值并不简单，因为它们的绝对值取决于实验方案。
例如，无论细胞的质量如何，对更深的测序将导致更多的reads和更多表达的特征量。
类似地，在方案中使用更多的加标RNA将导致更高的加标比例。
为了获得合适的阈值，我们假设大多数数据集由高质量的细胞组成，并且识别含有各种异常QC指标的细胞。

基于所有细胞中每个指标中值的中值绝对偏差（MAD）来定义异常值。
我们删除log-库大小值低于log库大小中间值的3 MAD的细胞。
对数转换可以提高小的数量值的分辨率，特别是当原始值的MAD等于或大于中值时。
我们还去除了表达基因的对数转换数量低于中值3个MAD的细胞。

```{r}
libsize.drop <- isOutlier(sce$total_counts, nmads=3, type="lower", 
    log=TRUE, batch=sce$PlateOnco)
feature.drop <- isOutlier(sce$total_features_by_counts, nmads=3, type="lower", 
    log=TRUE, batch=sce$PlateOnco)
```

这个`batch=`选项确保能够在指定的不同水平的板/癌基因因子中别出异常值。
上面的选项将会让`isOutlier()`这功能适应不同细胞板之间的QC指标的系统差异 (Figure \@ref(fig:qcplot416b)),
这些系统之间的差异可能是由于处理技术的差异产生的（例如，测序深度的差异）而不是质量的变化而导致的。
同样的推理适用于癌基因诱导状态，其中出于生物学原因诱导细胞可能天然地含有较少的表达基因。
如果不考虑这些系统性差异，则会增加MAD估计值并影响低质量细胞的去除。

我们以类似的方式识别基于比例的指标的异常值。
这里，我们不需要进行任何转换，因为我们正在识别大的异常值，因此在原始衡量比例上已经非常清楚。
我们不需要使用线粒体比例，因为我们已经具有该数据集的加标比例（其用于类似目的）。
同时可以避免由细胞类型之间产生的线粒体含量的差异所引起的潜在问题，这可能会进一步影响异常值的识别。

```{r}
spike.drop <- isOutlier(sce$pct_counts_ERCC, nmads=3, type="higher",
    batch=sce$PlateOnco)
```

按列进行子集化且只保留能够通过上面过滤条件的高质量细胞。
我们检查每次过滤去除的细胞数量以及保留下来的细胞总数。
如果大部分细胞被过滤掉（> 10％）可能表明数据质量存在整体问题。

```{r}
keep <- !(libsize.drop | feature.drop | spike.drop)
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop),
    BySpike=sum(spike.drop), Remaining=sum(keep))
```

然后我们将 `SingleCellExperiment` 象子集化以仅保留假定的高质量细胞。
另外，我们还将原始对象保存到文件中以供以后使用。

```{r}
sce$PassQC <- keep
saveRDS(sce, file="416B_preQC.rds")
sce <- sce[,keep]
dim(sce)
```

**Aaron的评论**

- 有关更详尽的基于异常值来检测低质量细胞的讨论，请参阅 `r simpleSingleCell:::.link("qc", "Assumptions of outlier identification", "本节")`。
- `isOutlier()` 还将返回精确的过滤器阈值给每个质控指标（如果batch=已指定，则在每个批次中）。
这些值可用于检查自动选择的阈值是否合适。

    ```{r}
    attr(libsize.drop, "thresholds")
    attr(spike.drop, "thresholds")
    ```

# 细胞周期阶段的分类

我们使用Scialdone等人描述的预测方法 @scialdone2015computational基于基因表达数据将细胞分类为不同的细胞周期阶段。
使用训练数据集，计算每对基因之间两个基因之间表达差异的信号。
选择具有跨细胞周期阶段的信号变化的基因对作为标记。
然后，基于每个标记对的观察到的信号是否与一个阶段或另一个阶段一致，可以将测试数据集中的细胞归类到对应的阶段。

这种方法是由`r Biocpkg("scran")`包中的`cyclone`函数实现的。
该包包含一组预先训练好的鼠标数据标记对，我们可以在`readRDS`函数中加载。
另外我们使用我们数据集中每个基因的Ensembl标识符来匹配上预先训练好的基因对中的名称。

```{r}
set.seed(100)
library(scran)
mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", 
    package="scran"))
assignments <- cyclone(sce, mm.pairs, gene.names=rowData(sce)$ENSEMBL)
```

HSC数据集中每个细胞的 `cyclone` 结果如图\@ref(fig:phaseplot416b)所示。
每个细胞在每一个周期阶段会有一个分数，如果分数越高意味着那个细胞在那个细胞周期的概率就更大。
我们重点关注细胞在G1和G2/M周期的分数，因为这几个细胞周期的信息量最大。

```{r phaseplot416b, message=FALSE, fig.cap="在416B数据集上使用基于标记对的分类的细胞周期阶段评分。每个点代表一个细胞，根据其G1和G2 / M期的分数绘制。"}
plot(assignments$score$G1, assignments$score$G2M, 
    xlab="G1 score", ylab="G2/M score", pch=16)
```

如果G1评分高于0.5且高于G2 / M评分，则细胞被分类为处于G1期; 
如果G2 / M评分高于0.5且高于G1评分，则处于G2 / M期;  
如果得分均不高于0.5，则处于S阶段。
在这里，大部分细胞被归类为处于G1期。我们将这些分配保存到`SingleCellExperiment`对象中供以后使用。

```{r}
sce$phases <- assignments$phases
table(sce$phases)
```

存储于 `r Biocpkg("scran")`包中的预先训练好的分类方法可适用于人类和小鼠的数据。 
虽然这里使用的小鼠分类方法是根据胚胎干细胞的数据进行训练的，但对于其它细胞类型仍然是准确的 [@scialdone2015computational]。
这可能是由于与细胞周期相关的转录过程的保守性所造成的 [@bertoli2013control;@conboy2007cell]。
基于配对的方法也是一种非参数化过程，能很好的处理数据集之间的大多数技术产生的差异。

__Aaron的评论:__

- 为了消除由细胞周期阶段引起的混杂效应，我们可以过滤细胞以仅保留特定阶段（通常为G1）的细胞以方便下游分析。
或者，如果不可忽略数量的细胞处于其他阶段，我们可以使用指定的相位作为阻塞因子。
这可以在不丢弃信息的情况下防止细胞周期效应，这将会在后面进行更详细地讨论。
- 由于使用不同的实验方法，如果使用与训练数据集中使用的数据明显不同，使用同源法人分类的方法可能会不准确。
在这种情况下，用户可以使用`sandbag` 功能对自己的训练数据库构建自定义的分类标准。
对于没有预训练好的分类方法的其他模型生物，这也是必要的。
- 在应用 `cyclone`之前不要过滤低丰度基因。
即使基因不在任何细胞中表达，如果它是细胞阶段性具有特异性，它仍可用于分类。
虽然相对于其它基因，这些基因缺乏表达，但其仍然会产生信息对，直接过滤它们会降低分类的能力。

# 检查基因水平表达指标

## 检查表达最高的基因

我们检查了表达量最高的那些基因 (Figure \@ref(fig:topgene416b)).
表达量最高的基因通常由参与基本构成的转录物组成，例如核糖体或线粒体蛋白质的转录物。
如果这些表达量高的基因是由其它类型的RNA构成，与生物学预期的结果不同，对这些不同的特征需要引起我们的关注。
例如在表达量高的基因中含有许多加标转录物，意味着在文库制备过程中加入了过多的加标RNA，而核糖体蛋白的缺失或者其假基因的存在会导致非最优的比对结果。

```{r topgene416b, fig.asp=1.2, fig.wide=TRUE, fig.cap="分配给416B数据集中前50个最高丰富特征的总计数百分比。对于每个要素，每个条形表示为m每个细胞分配给该要素的百分比，而圆圈表示所有细胞的平均值。条形图根据每个细胞中表达的特征的总数着色，而圆形根据特征是否标记为控制特征而着色。"}
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotHighestExprs(sce, n=50) + fontsize
```

##过滤掉低丰度基因

低丰度基因是存在问题的，为零或接近零的计数不包含太多能进行可靠统计推断的信息。
在涉及假设检验的应用中，这些基因不能提供足够的证据来拒绝原假设，但它们仍然会增加多重检验校正的严重度。
计数的离散性也可能干扰统计过程，例如，通过影响连续近似的准确性
因此，在进行下游分析之前，通常许多RNA-seq分析流程中都会去除低丰度基因。

最佳的过滤策略取决于下游的应用。
与去除underpowered的测试所需相比，通常需要一个更加进击地过滤来消除离散型（例如标准化）。
对于假设检验，过滤器的统计量也应该独立于零假设下的检验统计量[@bourgon2010independent]。
因此，我们（或相关函数）将根据需要在每个步骤进行过滤，而不是对整个分析应用单个过滤器。

有几个指标可以用来定义低丰度基因。
最明显的是每个基因的平均计数，在数据集中的所有细胞中计算。
我们使用`calcAverage()`函数计算，并对单细胞之间的库大小差异进行一些调整。
我们通常观察到低表达基因平台后中度表达基因的峰值 (Figure \@ref(fig:abhist416b))。

```{r abhist416b, fig.cap="416B数据集中所有基因的对数平均计数的直方图。"}
ave.counts <- calcAverage(sce, use_size_factors=FALSE)
hist(log10(ave.counts), breaks=100, main="", col="grey80", 
    xlab=expression(Log[10]~"average count"))
```

最小阈值可用于过滤掉表达量低的基因
下面的例子展示如何移除平均计数小于1的基因。
`demo.keep`中的`TRUE`值对应着过滤后保留下来的行/基因的数目。

```{r}
demo.keep <- ave.counts >= 1
filtered.sce <- sce[demo.keep,]
summary(demo.keep)
```

我们同时还检查了表达的每个基因的细胞数量。
这个量在大多数基因中与平均计数密切相关，因为在大多数细胞中，细胞表达将导致更高的计数平均值 (Figure \@ref(fig:nexprshist416b))。
只在少数细胞表达的基因通常是没什么意义的，因为他们很可能是因为扩增中假象造成的（尽管它们也可能来自罕见的群体）。 
我们可以将这种低于n个细胞表达的基因移除。

```{r nexprshist416b, fig.cap="416B数据集中表达每个基因的细胞数和相对于对数平均计数的关系。颜色强度对应给定位置的基因数量。"}
num.cells <- nexprs(sce, byrow=TRUE)
smoothScatter(log10(ave.counts), num.cells, ylab="Number of cells", 
    xlab=expression(Log[10]~"average count"))
```

如上所述，我们将在每个步骤使用这些过滤方法，而不是只应用于`sce`的子集中。
这可确保在每个应用程序中使用最合适的过滤方法。
尽管如此，我们去除了在任何细胞中不表达的基因，以减少下游分析的计算量。
些基因不提供任何有效信息，并且可以通过任何过滤方法去除。

```{r}
to.keep <- num.cells > 0
sce <- sce[to.keep,]
summary(to.keep)
```

# 细胞特异性偏差的标准化

## 使用反卷积方法处理零计数

Read 计数受细胞间捕获效率和测序深度的差异影响[@stegle2015computational]。
在下游定量分析之前，需要归一化处理来消除这些细胞特异性偏差。
这通常基于假设大多数基因在细胞之间没有表达差异(DE) 来进行的。
两个细胞之间的非差异表达基因的任何系统差异代表偏差并通过缩放换算去除。
更具体地，"size factors"被计算，其表示在每个库应缩放换算的程度。

Size factors 可以用不同的方法计算,例如使用`r Biocpkg("DESeq2")`包中的`estimateSizeFactorsFromMatrix` 函数[@anders2010differential;@love2014moderated]，或者使用 `r Biocpkg("edgeR")`包中的`calcNormFactors` 函数 [@robinson2010scaling] 。
可是，由于低计数和零计数量是占主导的，单细胞数据直接使用传统的基于批量数据的方法可能是有问题的。
为了克服这个问题，我们将来自许多细胞的计数汇集起来以增加计数的大小，来准确估计size factor[@lun2016pooling]。
然后。Pool-based size factors“去卷积”到cell-based factors，并用于每个细胞的表达谱的标准化。

```{r}
sce <- computeSumFactors(sce)
summary(sizeFactors(sce))
```

Size factors 与所有细胞的文库大小密切相关 (Figure \@ref(fig:normplot416b))。
这再次表明细胞之间的大多数系统差异是由捕获效率或测序深度的差异导致的。
细胞之间的任何表达差异(DE)将导致总计数和size factors之间的非线性趋势，和或者增加围绕趋势的散幅。
我们在癌基因诱导后观察到这方面的现象，其中诱导后szie factors系统性地降低了。
这与诱导后基因上调引入的构成偏差一致 [@robinson2010scaling]。

```{r normplot416b, fig.cap="来自解卷积的尺寸因子，针对416B数据集中所有细胞的文库大小绘制。轴以对数刻度显示。控制组细胞以黑色显示，癌基因诱导的细胞以红色显示。"}
plot(sce$total_counts/1e6, sizeFactors(sce), log="xy",
    xlab="Library size (millions)", ylab="Size factor",
    col=c("red", "black")[sce$Oncogene], pch=16)
legend("bottomright", col=c("red", "black"), pch=16, cex=1.2,
    legend=levels(sce$Oncogene))
```

__Aaron的评论:__

- 虽然反卷积方法对于scRNA-seq数据中的高频率零计算非常好用，但是吐过太多计数为零，这方法将会失效。
这情况下size factors将会是负数，显然是没有道理的。 
为了避免这种情况，`computeSumFactors`函数将在计算size factors之前自动删除低丰度的基因。
基因库的调整后的大小平均计数低于指定阈值（`min.mean`）将被忽略。
对于read计数数据，通常取用默认阀值为1。
- 基于细胞的质控(QC)应在标准化之前进行，以去除只含有少量表达基因的细胞。
否则，computeSumFactors()可能会在低质量细胞中产生负的size factors。
这是因为在这些细胞中存在太多的零的计数，进而降低了消零汇集的有效性。
有关`computeSumFactors`函数如何解决负size factors的讨论可以参与 `?computeSumFactors` 。
- 该sizes参数可用于指定用于计算szie factors的pool大小的数量。
越大的size会有更加准确的估算，但是同时要消耗更多的计算时间和内存。
通常，所有都sizes应该高于20个细胞，以确保每个池中有足够的非零表达量。
有效汇集的细胞总数也应至少为100。
- 对于高度不同的数据集，建议对细胞进行粗略聚类以削弱非DE假设。
这可以通过`quickCluster()`函数完成，其结果通过`clusters`参数传递给在`computeSumFactors()`函数。
我们在下一个`r simpleSingleCell:::.link("umis", "Normalization of cell-specific biases", "流程")`中使用更大的数据集演示了这种方法。

## 为加标转录物计算 separate size factors 

根据内源基因计数计算的size factors通常不适合标准化加标转录本的计数。
如果一个实验的文库没有定量，即自每个文库的cDNA的量不是在汇集和多重测序之前均衡。
在这里含有更多的RNA的细胞会有更大的内源基因的计数，因此需要更大的size factors去缩小这个计数量。
可是，在文库制备时，每个细胞中添加了相同量的加标RNA。
这意味着加标转录本的计数不受RNA含量的影响。
试图用基于基因的size factors正常化加标计数，将导致过度标准化和不准确的表达定量。
类似的原因可应用于当文库量化。
对于恒定的cDNA总量，内源RNA含量的任何增加都将抑制加标转录物的覆盖度。F
结果会导致加标计数的偏差将与基于基因的size factors所捕获的值相反。

为了确保标准化的准确执行，我们单独地为加标组计算了一组size factors。
在每个细胞中，特定地加标size factors被定义为加标组中所有转录物的总计数。
这基于所有加标转录物都没有表达差异，这是非常合理的，因为我们应当在每个细胞中加入等量的加标RNA[@lun2017assessing]。
(有关加标物归一化的更详细讨论，请参见下文。)
这些 size factors 单独储存于 `SingleCellExperiment` 的对象中通过设置 `computeSpikeFactors`中单独的选项`general.use=FALSE`。
该选项`type="ERCC"`确保它们仅与加标转录物一起使用，而不对内源基因起作用。

```{r}
sce <- computeSpikeFactors(sce, type="ERCC", general.use=FALSE)
```

## 在基因表达中应用 size factors 

计数数据用于计算归一化的对数化表达量，可用于下游分析。
预先在计数量加1，以避免零计数产生未定义值后，将每个值定义为每个计数的log 2 -ratio到相应细胞的size factors。
按size factor划分可确保消除任何由细胞产生的偏差。
如果特定的加入 size factors存在于`sce`中, 它们将自动应用于将加标转录物标准化，使它与内源基因分开。

```{r}
sce <- normalize(sce)
```

对数转换非常有用，因为它意味着值的任何差异直接表示细胞之间表达量的log2倍的变化。
这通常比覆盖率的绝对差异更为重要，需要在总体丰度的背景下进行解释。
对数变换也提供了方差稳定性的测量 [@law2014voom], 防止具有大方差的高丰度基因影响下游分析。
除了其它试验因素外，计算值也会储存在`"logcounts"矩阵中。

```{r, echo=FALSE, results="hide"}
gc()
```

# 在基因表达中模拟技术产生的噪音

观察到的基因表达值得多样性，可以由镇长的生物特异性或者没有意义的技术噪声所产生。 
为了区分这两种不同的因素，我们需要对每个基因中由技术噪音所产生的表达量的差值进行建模。
这里我们会使用加入转录物，并确保它在每个细胞的加入量是相同的。 
因此，加标转录物应该没有生物性的不同，任何它们的差异都是由技术噪音所造成的。

我们使用trendVar()函数将mean-dependen趋势拟合到加入转录物对数化的表达量值的差值。
我们设置`block=`选项，来防止每个细胞的原始平板不同，以确保板之间的技术差异不会扩大差异。
根据给定的基因平均丰度，趋势的拟合值，然后评估该基因的技术噪音的影响。
最终通过用`decomposeVar`函数从每个基因的总差异中减去，技由术噪音产生的成分，来计算生物学成分所产生的差异。

```{r}
var.fit <- trendVar(sce, parametric=TRUE, block=sce$Plate,
    loess.args=list(span=0.3))
var.out <- decomposeVar(sce, var.fit)
head(var.out)
```

我们检查趋势变化，来确定它和加入物的变化相对应(Figure \@ref(fig:hvgplot416b)))。
波状形的阴影是对数表达量的平均方差趋势的典型例子。
随着平均值从零增加，观察到方差的线性增加，因为当计数增加时可能有更大的方差。
在非常高的丰度下，由于大数定律，样本的技术噪声的影响会减小，进而导致方差减小。

```{r hvgplot416b, fig.cap="416B数据集中每个基因的归一化对数表达量的方差，相对于平均对数表达量作图。蓝线表示适用于加标转录本（红色）方差的平均相关趋势。"}
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression")
curve(var.fit$trend(x), col="dodgerblue", lwd=2, add=TRUE)
cur.spike <- isSpike(sce)
points(var.out$mean[cur.spike], var.out$total[cur.spike], col="red", pch=16)
```

我们检查具有最大生物成分的基因的表达值的分布。
这确保了方差估计不是由一个或两个h含有异常值的细胞产生的 (Figure \@ref(fig:hvgvioplot416b)).

```{r hvgvioplot416b, fig.cap="416B数据集中具有最大生物成分的前10个基因的归一化对数表达值的小提琴图。每个点代表单个细胞中的表达量的对数值。"}
chosen.genes <- order(var.out$bio, decreasing=TRUE)[1:10]
plotExpression(sce, features=rownames(var.out)[chosen.genes]) + fontsize
```

** Aaron的评价:**

- 在实践中，趋势拟合因加标转录物的量不足及其丰度的不均匀分布而变得复杂。
有关如何优化拟合的更多详细信息，请参见 `r simpleSingleCell:::.link("var", "Details of trend-fitting parameters", "这里")` 。
- 在没有加标的情况下，用户可以设定`use.spikes=FALSE`适应内源基因变异的趋势。(见`r simpleSingleCell:::.link("var", "Wwhen spike-ins are unavailable", "此处")`).
或者，我们可以创建一个基于Poisson的技术噪音趋势, 具体描述见 `r simpleSingleCell:::.link("tenx", "Modelling the mean-variance trend", "这里")`.
- 通常可以从 `decomposeVar`中获得负性的生物噪音。
在直观上，这些负性的生物噪音毫无意义，因为基因不可能具有除了技术噪音外的差异。
尽管如此，这些值还是可以由于总方差的估计不精确而导致，特别是对于数量少的细胞。
- `decomposeVar`还会产生一个p值，可用于定义特定错误发现率(FDR)的阀值所对应的HVGs。
我们将在后面更详细地讨论这个问题，因为在数据探索期间不需要正式检测HVG来进行特征选择。

# 移除批次效应

如上面所述，数据收集发生在两个平板上。
平板之间处理的小得不可控制的差异可导致批次效应，即不同平板上的细胞之间的表达的系统差异。
这些差异并不紧要，可以通过应用`r Biocpkg("limma")`包中的`removeBatchEffect()`函数来消除[@ritchie2015limma]。
这会消除初始板的影响，同时考虑了致癌基因诱导的（通常非常有趣的）效应。

```{r}
library(limma)
assay(sce, "corrected") <- removeBatchEffect(logcounts(sce), 
    design=model.matrix(~sce$Oncogene), batch=sce$Plate)
assayNames(sce)
```

对于非基于模型的下游分析步骤，例如聚类和大多数形式的降维，手动批量校正是必要的。
但是，如果分析方法可以接受设计矩阵，则阻断设计矩阵中的nuisance factors优于使用`removeBatchEffect()`。
这是因为后者不考虑剩余自由度的损失，也不考虑blocking factor的不确定性。

**Aaron的评论:**

- `removeBatchEffect()`执行线性回归并将blocking factors对应的系数设置为零。
只要每批中的种群组成已知（并提供为design=）或批次之间相同，这方法就是有效的。
这种假设对于该数据集是合理的，只要涉及两个平板上的细胞系群体是同源的
然而，在大多数scRNA-seq应用中，变异因子在批次之间并不相同，并且我们无法事先知道。
这促使使用更复杂的批量校正方法，例如`mnnCorrect()`。

# 使用PCA去除表达值的噪音

一旦对技术噪声进行建模,我们就可以使用主成分分析（PCA）来消除随机技术噪声
每个细胞格代表高维表达空间中的一个点，其中点的扩展代表总的差异。
PCA识别此空间中的轴，尽可能多地捕获这种差异。
每个轴都是一个主要组分（PC），任何早期的PC都会比后来的PC解析更多的差异。

我们假设涉及共同调节的基因组的生物过程将解释数据中大部分的差异。
如果是这种情况，则此过程应由一个或多个早期PC表示。
相反，随机技术噪声会独立影响每个基因，并将由后来的PC代表。
该`denoisePCA()`功能删除后来的PC，直到总丢弃差异等于PCA中所有基因中的技术噪音的总和。

```{r}
sce <- denoisePCA(sce, technical=var.out, assay.type="corrected")
dim(reducedDim(sce, "PCA")) 
```

该函数返回一个 `SingleCellExperiment`对象，其中`reducedDims`slot包含了每个细胞的PC分数。
目的是消除技术噪音并丰富保留PC中的生物信号。
这提高了下游分析（例如聚类）潜在生物学问题的分辨率。This improves resolution of the underlying biology during downstream procedures such as clustering.

__Aarond的评价:__

- `denoisePCA()` 只会使用具有正生物成分的基因，例如差异大于拟合趋势。
这保证了要丢弃的总的技术噪音引起的差异不会大于数据中的总差异。
- 对于`technical=`参数，该函数还将直接接受趋势函数（即`var.fit$trend`）或每个基因的技术噪音相关的向量。
这里，我们提供从`decomposeVar()`函数提供`DataFrame`,来允许函数调整批量校正后残余自由度的损失。
具体而言，批量校正矩阵的差异略微被低估，需要对技术噪音相关成分进行一些重新调整以进行补偿。
- 这里没有对丰度进行过滤，这确保了仍然可以检测到稀有子群体的PC。
离散性不是问题，因为低丰度基因也具有较低的差异，因此降低了它们对PCA的影响。
- 还可以获得原始表达矩阵的低秩近近似值，捕获等同于残留的PC的差异。
进行去噪是有用的，特别是对于那些下游分析步骤中需要用到基因的表达量。

```{r}
sce2 <- denoisePCA(sce, technical=var.fit$trend, 
    assay.type="corrected", value="lowrank") 
assayNames(sce2)
```

```{r, echo=FALSE, results="hide"}
rm(sce2)
gc()
```

# 在低维空间中可视化数据

## 使用PCA

我们通过构建前三个组成成分的成对PCA图来可视化细胞之间的关系(Figure \@ref(fig:pcaplot416b-onco))。
具有表达模式相似的细胞应该在图中聚集在一起，而表达模式不同的细胞应该相距比较远。
在这种情况下，我们观察到基于癌基因诱导状态的细胞有明显地分离，这与对转录组的预期效果是一致的。

```{r pcaplot416b-onco, fig.cap="Pairwise PCA plots of the first three PCs in the 416B dataset, constructed from normalized log-expression values of genes with positive biological components. Each point represents a cell, coloured according to oncogene induction status.", fig.width=9}
plotReducedDim(sce, use_dimred="PCA", ncomponents=3, 
    colour_by="Oncogene") + fontsize
```

对比之下，我们发现不同批次间没有明显的细胞分离 (Figure \@ref(fig:pcaplot416b-batch))。
这表明我们使用`removeBatchEffect()`函数进行批次修正是成功的。

```{r pcaplot416b-batch, fig.cap="416B数据集中前三个PC的成对PCA图，由具有阳性生物成分的基因的标准化表达量的对数值来构建。每个点代表一个细胞，根据癌基因诱导状态着色。", fig.width=9}
plotReducedDim(sce, use_dimred="PCA", ncomponents=3, 
    colour_by="Plate") + fontsize
```

注意，`plotReducedDim()` 将会使用已经存储好的PCA结果被`denoisePCA()`存储于`sce` 中。 
这使我们能够快速生成具有不同美学的新图，而无需重复整个PCA的计算。
同样，`plotPCA()`会使用现有可用的结果如果它存在于`SingleCellExperiment`中, 否则将重新计算它们。
用户应设置`rerun=TRUE`，使即在存在现有结果的情况下，也强制重新计算PC。

__Aaron的评论:__

- 对于每种可视化方法，可以将额外的细胞特异性信息结合到每个点的大小或形状中。
在大多数绘图参数中，使其中的`size_by=`和`shape_by=`参数来完成。T
- 在PCA中，其实更多的成分可用展示，但是这些成分通常信息量较小，它们能解析的差异就越小。
它们通常也更难以解释，因为它们被定义为正交的早期PCs（因此取决于在那些PCs中检测到的内容）。

## 使用 _t_-SNE

另一种广泛使用的降维方法是t-随机邻域嵌入 (_t_-SNE) 方法[@van2008visualizing]。
_t_-SNE 往往比PCA更好地分离更多不同群体中的细胞。
这是因为前者可以直接捕获高维空间中的非线性关系，而后者必须在线性轴上表示它们。
然而，这种改进是以更多计算量为代价的，并且需要用户考虑诸如随机种子和混乱度之类的参数（参见下面注释）。

我们使用`plotTSNE()`函数来演示了_t_-SNE 图的生成 \@ref(fig:tsneplot416b)。
我们设置了`use_dimred="PCA"` 去计算数据的 _t_-SNE 的低秩近似量, 允许算法利用先前的去噪步骤。

```{r tsneplot416b, fig.cap="使用一系列混乱度从416B数据集中的去噪PCs构建_t_-SNE 图。 每个点代表一个细胞，根据其癌基因诱导状态着色。条形表示每个轴上的细胞的坐标。", fig.width=15, fig.asp=0.5}
set.seed(100)
out5 <- plotTSNE(sce, run_args=list(use_dimred="PCA", perplexity=5),
    colour_by="Oncogene") + fontsize + ggtitle("Perplexity = 5")

set.seed(100)
out10 <- plotTSNE(sce, run_args=list(use_dimred="PCA", perplexity=10),
    colour_by="Oncogene") + fontsize + ggtitle("Perplexity = 10")

set.seed(100)
out20 <- plotTSNE(sce, run_args=list(use_dimred="PCA", perplexity=20),
    colour_by="Oncogene") + fontsize + ggtitle("Perplexity = 20")

multiplot(out5, out10, out20, cols=3)
```

_t_-SNE 是一种随机方法，因此用户应多次重复运行该算法以确保结果具有代表性。
脚本应设置种子（通过 `set.seed()` 命令) 去确保所选结果是可重复的。
还建议测试不同的混乱度参数，因为这将影响低维空间中的点的分布。

这里我们使用20的混乱度去调用`runTSNE()` ，并将 _t_-SNE 的结果存储于`SingleCellExperiment` 对象中。
如果我们想使用`plotTSNE()`创建新图时，这将避免我们重复计算，因为可以直接使用已经存储好的结果。
同样用户可以设置 `rerun=TRUE` 去强制重新计算即使在有存储结果的情况。

```{r}
set.seed(100)
sce <- runTSNE(sce, use_dimred="PCA", perplexity=20)
reducedDimNames(sce)
```

还有许多其它降维技术，虽然我们在这里就不深入探究了但也可以使用，例如，多维缩放，扩散图。
它们各有利弊 - 例如，扩散图(参见`plotDiffusionMap`) 沿着连续的轨迹放置细胞，适合于可视化分化等渐进过程 [@angerer2016destiny].

__Aaron的注释:__

- 有关如何解析 _t_-SNE 图的指南请访问该网站  http://distill.pub/2016/misread-tsne/。
这证明了二维嵌入中的聚集的距离，大小（扩展)几乎没有意义。

# 将细胞聚类成假定的亚群

## 根据表达数据定义细胞集聚

去噪的对数表达量用于将细胞聚类成推定的亚群。
具体来说，我们对细胞之间的欧几里德距离进行层次聚类，使用Ward的标准来最小化每个集群内的总差异。
这产生了树状图，将所选基因中具有相似表达模式的细胞聚合在一起。

```{r}
pcs <- reducedDim(sce, "PCA")
my.dist <- dist(pcs)
my.tree <- hclust(my.dist, method="ward.D2")
```

聚类被明确地定义为应用动态的树切割于树状图中 [@langfelder2008defining]。
这利用了树状图中分支的形状来细化聚类的定义，并且比`cutree`应用于更复杂的树状图更合适。
通过人工指定`cutreeDynamic`中的`cutHeight`可以获得对聚类的更多控制。
我们也通过设置`minClusterSize`比默认值20更低的值来避免远端小聚类的假阳性聚合。

```{r}
library(dynamicTreeCut)
my.clusters <- unname(cutreeDynamic(my.tree, distM=as.matrix(my.dist), 
    minClusterSize=10, verbose=0))
```

我们根据已知因素检查每个聚类中细胞的分布。
每个聚类由来自两个批次的细胞组成，表示聚集不是由批次效应造成的。
观察到每个聚类的组成的差异，由`Oncogene`对象表示，与癌基因诱导的生物学效应一致

```{r}
table(my.clusters, sce$Plate)
table(my.clusters, sce$Oncogene)
```

我们可视化所以细胞上的聚类分配使用 _t_-SNE 图 \@ref(fig:tsnecluster416b)。
通常将相邻细胞分配给相同的聚类，引导正确的聚类步骤。

```{r tsnecluster416b, fig.cap="416B数据集的去噪PC的t -SNE图。每个点代表一个细胞，并根据分配给它的聚类标识进行着色。"}
sce$cluster <- factor(my.clusters)
plotTSNE(sce, colour_by="cluster") + fontsize
```

我们使用轮廓宽度检查簇的分离度 (Figure \@ref(fig:silhouette416b))。
具有大的正轮廓宽度的细胞比更靠近同一个聚类相比于不同的聚类。
相反，具有负轮廓宽度的细胞更靠近其它不同的聚类，而不是分配和它有相同聚类的细胞中。
理想情况下，每个聚类都包含具有比较大的正宽度的细胞，表明它与其它聚类完全分离。

```{r silhouette416b, fig.cap="每个聚类中的细胞的轮廓宽度的条形图。为每个聚类分配一种颜色，并根据其指定聚类的颜色对具有正宽度的单元格进行着色。具有负宽度的任何细胞根据其最接近的聚类的颜色着色。显示每个聚类中所有细胞的平均宽度，以及数据集中所有细胞的平均宽度。"}
library(cluster)
clust.col <- scater:::.get_palette("tableau10medium") # hidden scater colours
sil <- silhouette(my.clusters, dist = my.dist)
sil.cols <- clust.col[ifelse(sil[,3] > 0, sil[,1], sil[,2])]
sil.cols <- sil.cols[order(-sil[,1], sil[,3])]
plot(sil, main = paste(length(unique(my.clusters)), "clusters"), 
    border=sil.cols, col=sil.cols, do.col.sort=FALSE) 
```

轮廓宽度可用于确定最大化聚类之间分离的参数值。
例如，我们可以改变`cutreeDynamic`中的切割高度或分割深度以最大化所有细胞的平均轮廓宽度。
这可以提供满意的初始聚类以供进一步检查
但是，请记住，聚类的粒度很像显微镜上的放大倍数。
可以使用不同的粒度(间隔尺寸)获得数据的不同视图，其中一些粒度可能在分离度量上是次优的。
如果用户不能为特定的生物问题提供所需的粒度，则不应该执着于使用具有最大分类度的聚类。

大多数细胞在图 \@ref(fig:silhouette416b), 中具有相对小的轮廓正宽度，表明簇之间的分离很弱。
这可能是过度聚类的症状，其中在癌基因诱导状态上明确定义的聚类被进一步分成不能明确分开的子集。 
尽管如此，我们将继续使用当前的聚类方法`my.clusters`, 因为它进一步为表征异质性提供了合理的区分。

```{r echo=FALSE, results='hide'}
gc()
```

**Aaron的注释:**

- 另一种聚类策略是使用从相关性导出的距离矩阵（例如，如`quickCluster`）。
这对于噪声和归一化误差更加有效，但对表达模式的细微变化不太敏感。
- Ward的标准和完全连锁均都可以产生球形和紧凑的聚类。
特别地，完全连锁有利于形成具有相同直径的聚类。
在某些情况下这非常合适，但当子群体的变异是不同时则不太合适。
当然，尝试其他方法是简单的（并且推荐），如果要执行某些评估（例如，使用轮廓宽度）。

## 检测聚类之间的标记基因

一旦通过聚类找到推定的亚群，我们就可以使用该`findMarkers`功能鉴定每个聚类的标记基因。
这一步执行了Welch $t$ 测试在每个基因和每对聚类之间的表达量的对数值 [@soneson2018bias]。
目的是测试每个聚类中的与其他聚类相比表达量的差异，同时防止引入不感兴趣的因素，例如板的起源(`r simpleSingleCell:::.link("de", "Blocking on uninteresting factors of variation", "此处")` 详情见).
顶端的表达差异基因可能是很好的候选标记，因为它们可以有效地区分不同聚类中的细胞。

```{r}
markers <- findMarkers(sce, my.clusters, block=sce$Plate)
```

对于每个聚类,相关的表达差异的结果会合并到单个输出列表中。
这允许通过从聚类之间的每个成对比较中，获取顶部差异表达基因，更简单地定义一组标记基因。
例如，为了从每个比较的前10个基因构建聚类1的标记基因集，可以过滤`marker set`以保留含有`Top`的小于或者等于10的行。
每个基因的其它统计数据也会被报道，包括调整后的$p$-values（见下文）和log-fold,相对于每个其它聚类的变化。

```{r, echo=FALSE, results="hide"}
old.digits <- options()$digits
options(digits=3)
```

```{r}
marker.set <- markers[["1"]]
head(marker.set, 10)
```

```{r, echo=FALSE, results="hide"}
# Crashing if cluster 1 is not what we think it is; 
# thus, avoid mismatch between text and results.
stopifnot(all(sapply(marker.set["Myh11",-(1:3)], sign)==1))
stopifnot(all(sapply(marker.set["Mcm2",-(1:3)], sign)==-1))

options(digits=old.digits)
```

我们保存候选标记基因列表以供进一步检查。

```{r}
write.table(marker.set, file="416B_marker_1.tsv", sep="\t", 
    quote=FALSE, col.names=NA)
```

我们可视化顶端候选基因的表达图谱，以验证表达差异信号是否稳健 (Figure \@ref(fig:heatmapmarker416b))。
与一些或所有其它聚类相比，大多数顶端标记在聚类1的细胞中具都会有强且一致的上调或下调。
简单查看一下热图，聚类1含有致癌基因诱导的细胞，具有DNA复制和细胞周期基因的强烈下调。
这与作为抗肿瘤发生反应的潜在诱导衰老现象一致[@wajapeyee2010senescence]。
可以使用`r Biocpkg("limma")`包中的`kegg`和`goana`来对进行聚类富集分析，对这些标记基因进行更全面的功能研究。

```{r heatmapmarker416b, fig.width=10, fig.asp=0.8, fig.cap="416B数据集中聚类1的顶端标记集的平均中心和标准化对数表达量的热图。柱颜色代表每个细胞所分配的聚类，原始平板或每个细胞的癌基因诱导状态，如图例所示。"}
top.markers <- rownames(marker.set)[marker.set$Top <= 10]
plotHeatmap(sce, features=top.markers, columns=order(sce$cluster), 
    colour_columns_by=c("cluster", "Plate", "Oncogene"),
    cluster_cols=FALSE, center=TRUE, symmetric=TRUE, zlim=c(-5, 5)) 
```

图 \@ref(fig:heatmapmarker416b) 中许多标记在所选择的聚类中都不是唯一的上调或者下调。
只测试独特表达差异往往是过于严格，因为它忽略了在两个或更多个聚类中表达的重要基因。
例如，在这样的混合群体中， CD4^+^-only, CD8^+^-only, 双阳性和双阴性T细胞, _Cd4_ 或 _Cd8_ 都不会被检测为亚群特异性标志物，因为每个基因都在两个亚群中有表达。
通过我们的方法，这两个基因将被选为候选标记，因为它们将是至少一对亚群之间的差异表达基因。
选择标记组可以被选来表征亚群，这比找到唯一的差异表达基因的方法更加灵活。

我们强烈建议选择一些标记用于实验验证，并使用独立的重复细胞群进行验证。
目的是鉴定表达上调标记物并且不表达下调标记物的相应的细胞子集。
理想地，在验证期间还将使用不同的用于量化表达的技术，例如荧光原位杂交或定量PCR。
这证实了亚群确实存在并且不是scRNA-seq或由于计算分析产生的人为产物。

__Aaron的注释:__

- 通过设置`direction="up"`, `findMarkers`将仅返回在每个聚类中与其它聚类相比上调的基因。 
这在高度异质的群体中很方便，可以专注于识别每个聚类的基因。
虽然缺乏基因表达也可能提供一定的信息，但这对于正向鉴定则没那么作用。
- `findMarkers`也可以指导在所选择的聚类和所有其它聚类之间找到有表达差异的基因。
这应该通过设置 `pval.type="all"`来完成,该设置将每个基因的p值定义为涉及所选聚类的所有成对对比的最大值。 
结合使用 `direction="up"`, 可用于识别每个聚类中唯一的标记。
然而，这方法对过度聚类很敏感，因为如果将聚类分成两个较小的子聚类，则不再存在独特的标记基因。
- 必须强调的是，这里计算的（调整的）p值不能被直接地解释为测量significance的度量。
这是因为聚类已经被根据经验从数据中识别出来了，参见 `r simpleSingleCell:::.link("de", "Misinterpretation of DE $p$-values", "此处")`.

# 结束语

完成基本分析后，, 通常要使用`saveRDS` 函数去保存`SingleCellExperiment` 对象到文件中。
然后使用`readRDS`函数该对象可以轻松的恢复并加载到新的R窗口中。
这允许我们进行下一步的工作而不必重复上述所有处理步骤。

```{r}
saveRDS(file="416B_data.rds", sce)
```

有多种方法可用于对处理过的表达数据进行更复杂的分析。
例如，细胞可以按照时间进行排序。 (e.g., 沿着分化途径进行排序)，使用到`r Biocpkg("monocle")` [@trapnell2014dynamics] or `r Biocpkg("TSCAN")` [@ji2016tscan]两个包; 
细胞状态层次结构可以用 `r Biocpkg("sincell")` 包来进行表征分析。 [@julia2015sincell];
可以使用 `r Biocpkg("Oscope")`来识别oscillatory behaviour。 [@leng2015oscope].
HVG可用于基因集富集分析，以识别具有差异活动的生物途径和过程。可以使用专门为传统批量数据设计的`r Biocpkg("topGO")`包或者专门给单细胞设计的`r Biocpkg("scde")`包 [@fan2016characterizing]。
这些分析的完整描述过程，超出了本工作流程的范围，因此建议感兴趣的用户查阅相关文档。

```{r, echo=FALSE, results='hide'}
gc()
```

All software packages used in this workflow are publicly available from the Comprehensive R Archive Network (https://cran.r-project.org) or the Bioconductor project (http://bioconductor.org).
The specific version numbers of the packages used are shown below, along with the version of the R installation.

```{r}
sessionInfo()
```

# References

