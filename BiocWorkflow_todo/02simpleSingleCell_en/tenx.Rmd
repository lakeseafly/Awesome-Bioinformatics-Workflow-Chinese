---
title: 从基于液滴的实验方法来分析单细胞RNA测序数据
author: 
- name: Aaron T. L. Lun
  affiliation: Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{04. Droplet-based data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
output: 
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
#bibliography: ref.bib
---

```{r, echo=FALSE, message=FALSE, results="hide", cache=FALSE}
library(BiocStyle)
library(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE, cache=TRUE)
opts_chunk$set(fig.asp=1)
```

# 概述 

基于液滴的scRNA-seq实验方法来捕获液滴中的细胞可用于大规模多重文库制备[@klein2015droplet;@macosko2015highly]。
这大大增加了scRNA-seq研究的通量，允许在常规实验中分析数万个单个细胞。
但是，它（再次）与先前工作流程存在一些差异，以反映基于液滴的数据的一些独特方面。

在这里，我们描述了来自10X Genomics的外周血单核细胞（PBMC）数据集进行简要分析 [@zheng2017massively]。
这些数据可从[10X Genomics网站](https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc4k)公开获得, 
我们从中下载原始基因/条形码计数矩阵，例如 _CellRanger_ 流程中细胞calling之前。

```{r}
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
raw.path <- bfcrpath(bfc, file.path("http://cf.10xgenomics.com/samples",
    "cell-exp/2.1.0/pbmc4k/pbmc4k_raw_gene_bc_matrices.tar.gz"))
untar(raw.path, exdir=file.path(tempdir(), "pbmc4k"))
```

# 数据准备

## 在稀疏的矩阵中读取计数

我们使用`r Biocpkg("DropletUtils")` 包中的 `read10xCounts()` 函数加载原始计数矩阵。
这将创建一个`SingleCellExperiment`其中每列对应一个细胞的条形码。 

```{r}
library(DropletUtils)
fname <- file.path(tempdir(), "pbmc4k/raw_gene_bc_matrices/GRCh38")
sce <- read10xCounts(fname, col.names=TRUE)
sce
```

这里，每个计数表示分配给细胞条形码的基因的独特分子标识符（UMI）的数量。
请注意这里的计数是以稀疏矩阵的形式加载的，例如`r CRANpkg("Matrix")`中的`dgCMatrix`就是其中一个例子。
这样避免了需要分配内存去保持零计数，这样对于低覆盖率的scRNA-seq来说是非常节省内存的。

```{r}
class(counts(sce))
```

## 注释行

我们将行重新标记为基因符以方便计数
这里用的是 `uniquifyFeatureNames()`函数,该函数确保在重复或缺失符号的情况下的唯一性。 

```{r}
library(scater)
rownames(sce) <- uniquifyFeatureNames(rowData(sce)$ID, rowData(sce)$Symbol)
head(rownames(sce))
```

我们还确定每个基因的染色体位置。
线粒体位置对于后期质控特别有用。

```{r}
library(EnsDb.Hsapiens.v86)
location <- mapIds(EnsDb.Hsapiens.v86, keys=rowData(sce)$ID, 
    column="SEQNAME", keytype="GENEID")
rowData(sce)$CHR <- location
summary(location=="MT")
```

# 从空水滴中调用细胞

## 测试与外界表达的偏差

基于液滴的数据的一个有趣方面是我们没有先验知道哪些液滴（即细胞条形码）实际上包含细胞，哪些是空的。
因此，我们需要根据观察到的表达变化谱从空液滴中调用细胞。
这不是完全简单的，因为空液滴可以包含可以捕获和测序外界（即细胞外）的RNA。
总计数的分布表现出具有大和小总计数的条形码之间的急剧转变 (Figure \@ref(fig:rankplot)),
可能分别对应于含细胞和空液滴。

```{r rankplot, fig.cap="PBMC数据集中每个条形码的总UMI计数，根据其排名绘制（按总计数的降序排列）。还示出了拐点和拐点的推断位置。"}
bcrank <- barcodeRanks(counts(sce))

# Only showing unique points for plotting speed.
uniq <- !duplicated(bcrank$rank)
plot(bcrank$rank[uniq], bcrank$total[uniq], log="xy",
    xlab="Rank", ylab="Total UMI count", cex.lab=1.2)

abline(h=metadata(bcrank)$inflection, col="darkgreen", lty=2)
abline(h=metadata(bcrank)$knee, col="dodgerblue", lty=2)

legend("bottomleft", legend=c("Inflection", "Knee"), 
	col=c("darkgreen", "dodgerblue"), lty=2, cex=1.2)
```

我们使用该 `emptyDrops()` 函数 来测试每个细胞条形码的表达变化谱是否与外境RNA库显着不同[@lun2018distinguishing]。
任何显着偏差都表明条形码对应于含有细胞的液滴。
我们称细胞的错误发现率（FDR）为0.1％，这意味着平均来说不超过0.1%调用的条形码是空液滴。

```{r}
set.seed(100)
e.out <- emptyDrops(counts(sce))
sum(e.out$FDR <= 0.001, na.rm=TRUE)
```

然后我们将`SingleCellExperiment` 对象子集化以仅保留检测到的细胞。

```{r}
# using which() to automatically remove NAs.
sce <- sce[,which(e.out$FDR <= 0.001)]
```

**Aaron的注释:**

- 使用`emptyDrops()`来计算Monte Carlo $p$-值 基于分子取样成液滴的Dirichlet-多项式模型。
这些 $p$-值是随机的，所以设置随机种子以获得可重复的结果非常重要。
-  Monte Carlo $p$-值得稳定性取决于用于计算它们的迭代次数。
这是使用 `emptyDrops()`中的 `niters=` 选项，将默认的速度设置为10000。
较大的值能够提升稳定性只是要付出时间的代价，所以用户可以根据自己能承受的时间来设置 `niters=`的最大值。
- 该函数假设具有总UMI计数并低于某个阀值(`lower=100`默认情况下)的细胞条码对应于空液滴。
并使用它们来估计外界表达变化谱。
根据定义，这些条形码不能是含有细胞的液滴，而是从假设检验中排除，因此以`NA`s在输出中表示。 
- 用户想使用 _CellRanger_ 流程中细胞calling的算法可以使用`defaultDrops()` 。
这往往是非常保守的，因为它经常丢弃具有低RNA含量的真正细胞（总计数低）
它还需要估计实验中预期的细胞数。

## cell-calling的诊断 

蒙特卡罗迭代次数 (由`emptyDrops()`中的`niters` 参数指定 ) 决定了 _p_valuesd的下限 [@phipson2010permutation]。
输出中`Limited`字段表明了特定条形码的计算的p值是否受迭代次数的限制。
如果任何不重要的条形码在`Limited`显示`TRUE`,我们可能需要增加迭代次数。
更大数量的迭代通常会导致这些条形码的p值降低，这可能允许在校正多次测试后检测它们。 

```{r}
table(Sig=e.out$FDR <= 0.01, Limited=e.out$Limited)
```

如上所述, `emptyDrops()`假设具有低的总UMI计数的条形码是空的液滴。
因此，对于所有这些条形码，初步假设应该是正确的。
我们可以通过检查低的总条形码值得分布来检测假设试验是不是保持其大小一致。
理想情况下，分布应接近均匀。

```{r ambientpvalhist, fig.cap="假定空滴液的$p$-values分布。"}
full.data <- read10xCounts(fname, col.names=TRUE)
set.seed(100)
limit <- 100   
all.out <- emptyDrops(counts(full.data), lower=limit, test.ambient=TRUE)
hist(all.out$PValue[all.out$Total <= limit & all.out$Total > 0],
    xlab="P-value", main="", col="grey80") 
```

接近零的大峰值表明具有低于`lower`的值的条形码的总数并非全部来自外部环境。
这可以通过进一步减少 `lower`的值去进一步排除条形码，其所对应于具有非常小的细胞的液滴。 

# 细胞的质控

前一步骤仅区从空液滴中区分了细胞，但没有说明细胞的质量。
液滴完全可能含有受损或垂死的细胞，需要在下游分析之前将其除去。
我们使用`calculateQCMetrics()`来计算一些质控(QC)的指标 [@mccarthy2017scater]并检查它们在图 \@ref(fig:qchist)中的分布。

```{r qchist, fig.width=10, fig.asp=0.5, fig.cap="PBMC数据集中QC指标分布的直方图。"}
sce <- calculateQCMetrics(sce, feature_controls=list(Mito=which(location=="MT")))
par(mfrow=c(1,3))
hist(sce$log10_total_counts, breaks=20, col="grey80",
    xlab="Log-total UMI count")
hist(sce$log10_total_features_by_counts, breaks=20, col="grey80",
    xlab="Log-total number of expressed features")
hist(sce$pct_counts_Mito, breaks=20, col="grey80",
	xlab="Proportion of reads in mitochondrial genes")
```

理想情况下，我们会删除具有小的文库或低的表达特征总数的细胞，如`r simpleSingleCell:::.link("reads", "Quality control on the cells", "之前所述")`。
然而，这可能会去除具有低RNA含量的细胞类型，尤其是在含有许多不同细胞类型的异质PBMC群体中。
因此，我们使用更宽松的策略，只去除具有大线粒体比例的细胞，使用它作为细胞损伤的标识。
(请记住，基于液滴的数据集通常没有加标RNA。)

```{r}
high.mito <- isOutlier(sce$pct_counts_Mito, nmads=3, type="higher")
sce <- sce[,!high.mito]
summary(high.mito)
```

**Aaron的注释:**

- 使用更宽松的过滤方法往往很大程度上是可追溯的。
在实践中，我们可能不会预先地知道群体异质性的程度和它是否出现在QC的指标中。
我们建议使用某些QC进行初始的分析，然后根据进一步的判断来选择是否放宽过滤的标准(或使其更加严格）。
请查阅 `r simpleSingleCell:::.link("qc", "Checking for discarded cell types", "此处")` 以获取潜在判断方法的示例。
- 去除含有大量线粒体的细胞，基于假定对细胞膜的损伤是适度，以保留线粒体。
细胞可能受到非常大的破坏，导致所有细胞质内容物丢失，只有剥离的细胞核保留用于测序。
这表现为线粒体比例为零，通常伴随着低文库大小/表达基因数量和可能低核糖体蛋白基因表达。
如果在数据中观察到这样的细胞聚类，他们可以通过对线粒体比例`type="lower"` 和 `log=TRUE`使用`isOutlier()`去除去它们。（以提高零附近的分辨率）

# 检查基因的表达

与之前的数据相比，这里每个基因的平均表达量要低得多 (Figure \@ref(fig:abhist))。
这是因为当将数千个细胞多路复用在一起进行测序时每个细胞的覆盖率会降低。

```{r abhist, fig.cap="PBMC数据集中每个基因的log 10-平均值的直方图"}
ave <- calcAverage(sce)
rowData(sce)$AveCount <- ave
hist(log10(ave), col="grey80")
```

如预期那样，最高表达基因的集合由核糖体蛋白和线粒体基因控制(Figure \@ref(fig:highexpr))。

```{r highexpr, fig.wide=TRUE, fig.asp=1.5, fig.cap="分配给PBMC数据集中前50个最丰富的功能的总计数百分比。对于每个要素，每个条形表示为单个细胞分配给该要素的百分比，而圆圈表示所有细胞的平均值。条形由每个细胞中表达的特征的总数着色。"}
plotHighestExprs(sce)
```

# 针对细胞特异性差进行标准化

像之前描述那样，我们执行了一些预聚类`r simpleSingleCell:::.link("umis", "Normalization of cell-specific biases", label="previously")`。
我们需要设置种子当我们使用`BSPARAM=IrlbaParam()` 由于`r CRANpkg("irlba")`的随机性。 

```{r}
library(scran)
library(BiocSingular)
set.seed(1000)
clusters <- quickCluster(sce, use.ranks=FALSE, BSPARAM=IrlbaParam())
table(clusters)
```

我们应用反卷积方法来计算所有细胞的size factors [@lun2016pooling]。
同样，我们`min.mean=0.1`用来解释UMI计数较低的现象。
具体化`cluster=` 还确保我们不会汇集非常不同的细胞。

```{r}
sce <- computeSumFactors(sce, min.mean=0.1, cluster=clusters)
summary(sizeFactors(sce))
```

Size factors 与文库大小密切相关 (Figure \@ref(fig:sfplot)),表明捕获效率和测序深度是引起偏差的主要因素。

```{r sfplot, fig.cap="PBMC数据集中所有细胞的size factors，根据文库大小绘制。"}
plot(sce$total_counts, sizeFactors(sce), log="xy")
```

最后，我们计算规一化的对数表达量值。
这里没有必要调用 `computeSpikeFactors()`, 因为加标准转录物是没有的。

```{r}
sce <- normalize(sce)
```

**Aaron的注释:**

- 基于液滴的较大数据集通常会在不同的批次或运行中生成。
在这种情况下，我们可以设置`quickCluster()`中的 `block=`，在每个批次或者每次运行中去聚类细胞。
如果每批中有足够的细胞，这可以在不影响性能的情况下明显地减少计算量。
- 即使在没有任何已知批量结构的情况下，我们也可以通过设置任意因子来提高速度，例如使用 `block=cut(seq_len(ncol(sce)), 10)`将细胞分成大小相等的十个“批次”。
记住我们不是为了解析聚类，所以使用多个冗余聚类群标签是没问题的。 
同样，这假设每个聚类足够大以支持反卷积。
- 在一个类似的说明中, `quickCluster()`和`computeSumFactors()` 都可以并行处理块或聚类。
这是使用`r Biocpkg("BiocParallel")`框架实现的, 该框架为一系列并行化策略提供帮助。

# 模拟均值-差异趋势

缺少加标转录物使得技术噪声的建模变得复杂。
一种选择是假设大多数基因没有表现出强烈的生物学变异，并且适应内源基因变异的趋势，详见
(see `r simpleSingleCell:::.link("var", "When spike-ins are unavailable", "此处")`。
然而，对于异质群体而言，这种假设通常是不合理的。
相反，我们假设技术噪声是遵循泊松的，并使用该`makeTechTrend()`z哎此基础上创建拟合趋势。

```{r}
new.trend <- makeTechTrend(x=sce)
```

我们估计所有基因的差异，并比较图 \@ref(fig:trendplot)的趋势拟合度。
基于泊松的趋势作为内源基因变异的下限。
这能让我们测量许多细胞中非零的生物成分, 这是与其它基于UMI-数据集相一致
(参见 `r simpleSingleCell:::.link("umis", "Modelling and removing technical_noise", "相对应的分析")` 的@zeisel2015brain 数据集)。

```{r trendplot, fig.cap="PBMC数据集中每个基因的归一化对数表达值的方差，相对于平均对数表达作图。蓝线表示与方差拟合的平均相关趋势，而红线表示泊松噪声。"}
fit <- trendVar(sce, use.spikes=FALSE, loess.args=list(span=0.05))
plot(fit$mean, fit$var, pch=16)
curve(fit$trend(x), col="dodgerblue", add=TRUE)
curve(new.trend(x), col="red", add=TRUE)
```

我们使用基于Poisson的趋势分解每个基因的差异，并检查具有最高生物成分的基因。

```{r}
fit$trend <- new.trend # overwrite trend.
dec <- decomposeVar(fit=fit) # use per-gene variance estimates in 'fit'.
top.dec <- dec[order(dec$bio, decreasing=TRUE),] 
head(top.dec)
```

我们可以绘制具有最大生物成分的基因，以验证它们确实是高度可变的 (Figure \@ref(fig:hvgplot))。

```{r hvgplot, fig.wide=TRUE, fig.cap="PBMC数据集中具有最大生物组分的前10个基因的归一化对数表达量的分布。每个点代表单个细胞中的对数表达量的值。"}
plotExpression(sce, features=rownames(top.dec)[1:10])
```

**Aaron的注释:**

- 基于泊松的趋势`makeTechTrend()`倾向产生具有高表达量的基因大的生物成分通常其对应的泊松噪声是比较低的（在对数表达空间中）。
这通常包括编码必需细胞组分（如核糖体蛋白）的所谓“管家”基因。
这些基因通常被认为对表征细胞异质性不产生影响，尽管这是有争议的，因为它们通常在各种条件下差异表达[@glare2002betaactin;@nazari2015gapdh;@guimaraes2016patterns]。
事实上，它们具有大量生物成分的事实表明它们在细胞中的表达存在很大差异，这需要进一步研究。
尽管如此，如果它们被认为是不重要的，那么通过将均值差异的趋势拟合到内源基因，可以减少它们的影响。

# 降维

我们使用 `denoisePCA()` 功能基于假设的泊松技术趋势来选择PCA后需要保留下来的维度。 
这涉及随机初始化当 `BSPARAM=IrlbaParam()`, 这会促使调用`set.seed()`去获取可重复的结果。 

```{r}
set.seed(1000)
sce <- denoisePCA(sce, technical=new.trend, BSPARAM=IrlbaParam())
ncol(reducedDim(sce, "PCA"))
```

```{r screeplot, fig.cap="PBMC数据集中每个主成分解释的差异。红线表示所选的PC数量。"}
plot(attr(reducedDim(sce), "percentVar"), xlab="PC",
	ylab="Proportion of variance explained")
abline(v=ncol(reducedDim(sce, "PCA")), lty=2, col="red")
```

查看前几个PCs已经能够揭示数据中含有强烈的子结构 (Figure \@ref(fig:pcaplot-init))。

```{r pcaplot-init, fig.cap="PBMC数据集中前三个PC的成对PCA图，由具有阳性生物成分的基因的标准化对数表达值构建。每个点代表一个细胞，由表达特征的对数值表示。", fig.width=9}
plotPCA(sce, ncomponents=3, colour_by="log10_total_features_by_counts")
```

这用 _t_-SNE 图重现 (Figure \@ref(fig:tsneplot-init)).
再次注意，我们设置`use_dimred=`去执行 _t_-SNE 计算在去噪表达式矩阵中.

```{r tsneplot-init, fig.cap="_从PBMC数据集的去噪PC构建的t- SA图。每个点代表一个细胞，并根据表达的特征的对数值来着色。"}
set.seed(1000)
sce <- runTSNE(sce, use_dimred="PCA", perplexity=30)
plotTSNE(sce, colour_by="log10_total_features_by_counts")
```

# 使用基于图形的方法进行聚类

我们构建了一个共享的最近邻图[@xu2015identification]并使用Walktrap算法来识别聚类。

```{r}
snn.gr <- buildSNNGraph(sce, use.dimred="PCA")
clusters <- igraph::cluster_walktrap(snn.gr)
sce$Cluster <- factor(clusters$membership)
table(sce$Cluster)
```

我们查看观察到的和预期的边缘权重的比率，以确认聚类是模块化的。
（我们不会看模块性其本身的得分，因为它会因聚类之间的数量级而变化，并且难以解释。）
图 \@ref(fig:clustermod) 表明大多数聚类分开得很好，几乎没有强烈的非对角线聚类。
```{r clustermod, fig.cap="相对于在随机链接的空模型下预期的总权重，相同聚类或不同聚类中的节点之间的总权重的log 10的比率。"}
cluster.mod <- clusterModularity(snn.gr, sce$Cluster, get.values=TRUE)
log.ratio <- log2(cluster.mod$observed/cluster.mod$expected + 1)

library(pheatmap)
pheatmap(log.ratio, cluster_rows=FALSE, cluster_cols=FALSE, 
    color=colorRampPalette(c("white", "blue"))(100))
```

我们对 _t_-SNE 图上的聚类标识进行了检验， (Figure \@ref(fig:tsneplot-cluster))以确认不同的聚类确实是分开的。

```{r tsneplot-cluster, fig.cap="从PBMC数据集的去噪PC构建的t- SEL图。每个点代表一个细胞，并根据其聚类标识进行着色。"}
plotTSNE(sce, colour_by="Cluster")
```

# 标记基因的检测

```{r, echo=FALSE, results="hide"}
# Hidden variables for use in text or hidden chunks,
# to avoid the need for manual changes.
chosen.platelets <- 9
```

我们使用`findMarkers()`来检测每个聚类中标记基因的数量。
同样，我们只关注每个聚类中的上调基因，因为这些基因对于异质群体中细胞类型的阳性鉴定会起到更好的作用。

```{r}
markers <- findMarkers(sce, clusters=sce$Cluster, direction="up")
```

我们更详细地检查了聚类 `r chosen.platelets`中的标记基因。 
_PF4_ 和 _PPBP_等基因的上调表明该聚类含有血小板或其前体。

```{r}
marker.set <- markers[["9"]]
head(marker.set[,1:8], 10) # only first 8 columns, for brevity
```

```{r, echo=FALSE, results="hide"}
# Checking 'marker.set' and 'chosen.platelets' are consistent.
stopifnot(identical(marker.set, markers[[chosen.platelets]]))

# Checking the cluster is what we wanted.
pf4 <- sapply(marker.set["PF4",-(1:3)], sign)
stopifnot(all(pf4==1))
```

这在图 \@ref(fig:heatmap), 得到证实，其中聚类 `r chosen.platelets`的转录变化谱明显不同于其他聚类。

```{r heatmap, fig.wide=TRUE, fig.cap=sprintf("PBMC数据集中聚类`r chosen.platelets`的顶部标记集的平均中心和标准化对数表达值的热图。列颜色表示每个细胞分配到的聚类，如图例所示。", chosen.platelets)}
chosen <- rownames(marker.set)[marker.set$Top <= 10]
plotHeatmap(sce, features=chosen, exprs_values="logcounts", 
    zlim=5, center=TRUE, symmetric=TRUE, cluster_cols=FALSE,
    colour_columns_by="Cluster", columns=order(sce$Cluster),
    show_colnames=FALSE)
```

# 结束语

完成基本分析后，我们将`SingleCellExperiment` 对象及其关联数据保存到文件中。
这避免了在进一步分析之前必须重复上述所有预处理步骤。

```{r}
saveRDS(sce, file="pbmc_data.rds")
```

All software packages used in this workflow are publicly available from the Comprehensive R Archive Network (https://cran.r-project.org) or the Bioconductor project (http://bioconductor.org).
The specific version numbers of the packages used are shown below, along with the version of the R installation.

```{r}
sessionInfo()
```

# References
