---
title: 分析含有UMI计数的单细胞RNA-seq数据
author: 
- name: Aaron T. L. Lun
  affiliation: &CRUK Cancer Research UK Cambridge Institute, Li Ka Shing Centre, Robinson Way, Cambridge CB2 0RE, United Kingdom
- name: Davis J. McCarthy
  affiliation: 
  - &EMBL EMBL European Bioinformatics Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SD, United Kingdom
  - St Vincent's Institute of Medical Research, 41 Victoria Parade, Fitzroy, Victoria 3065, Australia
- name: John C. Marioni
  affiliation: 
  - *CRUK
  - *EMBL
  - Wellcome Trust Sanger Institute, Wellcome Genome Campus, Hinxton, Cambridge CB10 1SA, United Kingdom
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{03. UMI count data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
output: 
  BiocStyle::html_document:
    titlecaps: false
    toc_float: true
bibliography: ref.bib
---

```{r style, echo=FALSE, results='hide', message=FALSE, cache=FALSE}
library(BiocStyle)
library(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE, cache=TRUE)
opts_chunk$set(fig.asp=1)
```

# 概述

在这个工作流程中，我们研究了小鼠脑细胞异质数据集 [@zeisel2015brain]。
这包含大约3000种不同类型的细胞，例如少突胶质细胞，小胶质细胞和神经元。
使用 Fluidigm C1 microfluidics 系统 [@pollen2014lowcoverage] 分离单个细胞，并使用基于UMI的方法进行细胞文库制备。
测序后，通过计数比对到每个基因的UMI的数量来定量表达。
所有内源基因，线粒体基因和加标转录物的计数数据可从下面网址中获得 http://linnarssonlab.org/cortex。

```{r}
library(BiocFileCache)
bfc <- BiocFileCache("raw_data", ask = FALSE)
base.url <- file.path("https://storage.googleapis.com",
    "linnarsson-lab-www-blobs/blobs/cortex")
mRNA.path <- bfcrpath(bfc, file.path(base.url, 
    "expression_mRNA_17-Aug-2014.txt"))
mito.path <- bfcrpath(bfc, file.path(base.url, 
    "expression_mito_17-Aug-2014.txt"))
spike.path <- bfcrpath(bfc, file.path(base.url, 
    "expression_spikes_17-Aug-2014.txt"))
```

# 准备好数据 

计数数据分布在多个文件中，因此要将它们合并为单个矩阵
我们定义了一个简单实用的函数，用于从每个文件加载数据。
（我们强调此函数仅与当前数据集相关，不能应用于其它数据集。
如果所有计数都在单个文件中并与meta数据分开，则通常不需要这样的步骤。

```{r}
readFormat <- function(infile) { 
    # First column is empty.
    metadata <- read.delim(infile, stringsAsFactors=FALSE, header=FALSE, nrow=10)[,-1] 
    rownames(metadata) <- metadata[,1]
    metadata <- metadata[,-1]
    metadata <- as.data.frame(t(metadata))

    # First column after row names is some useless filler.
    counts <- read.delim(infile, stringsAsFactors=FALSE, 
        header=FALSE, row.names=1, skip=11)[,-1] 
    counts <- as.matrix(counts)
    return(list(metadata=metadata, counts=counts))
}
```

使用此功能，我们读入了内源基因，ERCC加标转录本和线粒体基因的计数。

```{r}
endo.data <- readFormat(mRNA.path)
spike.data <- readFormat(spike.path)
mito.data <- readFormat(mito.path)
```

我们还需要重新排列线粒体数据的列，因为它的顺序与其他文件不一致。

```{r}
m <- match(endo.data$metadata$cell_id, mito.data$metadata$cell_id)
mito.data$metadata <- mito.data$metadata[m,]
mito.data$counts <- mito.data$counts[,m]
```

```{r, echo=FALSE}
stopifnot(identical(endo.data$metadata$cell_id, spike.data$metadata$cell_id)) # should be the same.
stopifnot(all(endo.data$metadata$cell_id==mito.data$metadata$cell_id)) # should now be the same.
```

在该给定数据集中，一些基因由对应于可供选择的基因位置的多行来表示。 
为了便于解释，我们将对应于单个基因的所有行的计数相加。

```{r}
raw.names <- sub("_loc[0-9]+$", "", rownames(endo.data$counts))
new.counts <- rowsum(endo.data$counts, group=raw.names, reorder=FALSE)
endo.data$counts <- new.counts
```

然后将计数组合成单个矩阵以构造 `SingleCellExperiment` 的对象。
为方便起见，所有细胞的meta数据都存储在同一对象中以供以后使用。

```{r}
library(SingleCellExperiment)
all.counts <- rbind(endo.data$counts, mito.data$counts, spike.data$counts)
sce <- SingleCellExperiment(list(counts=all.counts), colData=endo.data$metadata)
dim(sce)
```

我们添加基于基因的注释，标识与每类特征对应的行。
我们还确定每行的Ensembl标识符。

```{r}
# Specifying the nature of each row.
nrows <- c(nrow(endo.data$counts), nrow(mito.data$counts), nrow(spike.data$counts))
is.spike <- rep(c(FALSE, FALSE, TRUE), nrows)
is.mito <- rep(c(FALSE, TRUE, FALSE), nrows)
isSpike(sce, "Spike") <- is.spike

# Adding Ensembl IDs.
library(org.Mm.eg.db)
ensembl <- mapIds(org.Mm.eg.db, keys=rownames(sce), keytype="SYMBOL", column="ENSEMBL")
rowData(sce)$ENSEMBL <- ensembl

sce
```

```{r, echo=FALSE, results='hide'}
# Save some memory.
rm(mito.data, endo.data, spike.data, new.counts)
gc()
```

# 对细胞的质控

虽然该研究的原始作者在数据发布之前已经删除了低质量的细胞。
但是,我们还是可以使用`r Biocpkg("scater")`包来进行一些质控 [@mccarthy2017scater]，来检查剩下的细胞是否令人满意达到过滤后的要求。 

```{r}
library(scater)
sce <- calculateQCMetrics(sce, feature_controls=list(Mt=is.mito)) 
```

我们检查了所有细胞的质控(QC)指标分布 (Figure \@ref(fig:libplotbrain))。
此处的库大小至少比416B数据集中观察到的数量级低一个数量级。
这与使用UMI计数而不是read计数一致，因为每个转录物分子只能产生一个UMI计数，但在片段化后可以产生许多reads。
此外，加标比例比416B数据集中观察到的更多变化。
当存在许多细胞类型时，这可以反映每个细胞的内源RNA总量的更大变化。

```{r libplotbrain, fig.wide=TRUE, fig.cap="QC指标的直方图，包括大脑数据集中所有细胞的文库大小，表达基因数和分配给加标转录本或线粒体基因的UMI比例。"}
par(mfrow=c(2,2), mar=c(5.1, 4.1, 0.1, 0.1))
hist(sce$total_counts/1e3, xlab="Library sizes (thousands)", main="", 
    breaks=20, col="grey80", ylab="Number of cells")
hist(sce$total_features_by_counts, xlab="Number of expressed genes", main="", 
    breaks=20, col="grey80", ylab="Number of cells")
hist(sce$pct_counts_Spike, xlab="ERCC proportion (%)",
    ylab="Number of cells", breaks=20, main="", col="grey80")
hist(sce$pct_counts_Mt, xlab="Mitochondrial proportion (%)", 
    ylab="Number of cells", breaks=20, main="", col="grey80")
```

我们删除了库大小和表达特征数量的低异常值，以及加入物比例的大异常值。
同样，加标转录本的存在意味着我们不必使用线粒体比例。

```{r}
libsize.drop <- isOutlier(sce$total_counts, nmads=3, type="lower", log=TRUE)
feature.drop <- isOutlier(sce$total_features_by_counts, nmads=3, type="lower", log=TRUE)
spike.drop <- isOutlier(sce$pct_counts_Spike, nmads=3, type="higher")
```

然后通过组合不同的质控指标来过滤这些低质量的细胞。
大部分细胞被保留下来，这表明原始的质控步骤已经是足够的。

```{r}
sce <- sce[,!(libsize.drop | feature.drop | spike.drop)]
data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop), 
    BySpike=sum(spike.drop), Remaining=ncol(sce))
```

我们可以进一步提高细胞过滤的质量，通过设置`isOutlier`中的`batch`的一个或多个已知因素，例如小鼠或者板的原产地。
如之前所述，这将避免MAD的膨胀并提高去除低质量细胞的能力。
但是，为简单起见，我们不会这样做，因为前面的质控已经足够了。

```{r echo=FALSE, results='hide'}
gc()
```

# 细胞周期分类

将 `cyclone` [@scialdone2015computational] 应用于大脑数据集建议大多数细胞处于G1期 (Figure \@ref(fig:phaseplotbrain))。
这需要使用Ensembl标识符来匹配预定义的分类器。

```{r phaseplotbrain, message=FALSE, fig.cap="在大脑数据集上应用基于配对分类器的细胞周期阶段评分，其中每个点代表一个细胞。"}
library(scran)
mm.pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", package="scran"))
assignments <- cyclone(sce, mm.pairs, gene.names=rowData(sce)$ENSEMBL)
table(assignments$phase)
plot(assignments$score$G1, assignments$score$G2M, xlab="G1 score", ylab="G2/M score", pch=16)
```

但是，由于训练和测试数据集之间存在差异，因此对此结果的解释需要谨慎。
分类器使用C1 SMARTer数据的进行训练，并解释了该实验方法中的偏差。
大脑数据集使用UMI计数，其具有不同的偏差集合，例如，仅3'端覆盖，没有长度偏差，没有放大噪声。
此外，预计许多神经细胞类型位于G0休眠期，这与细胞周期的其他阶段不同[@coller2006new]。
`cyclone` 通常会将这些细胞分配给训练集中最接近的已知阶段，即G1。

```{r echo=FALSE, results='hide'}
gc()
```

# 检查基因水平的指标

图 \@ref(fig:topgenebrain)显示了大脑数据集中细胞群中表达最高的基因。
主要呗加标转录本占据，反映了跨越整个表达范围的加标浓度的使用。
正如预期的那样，还有许多与基本构成相关的表达的基因。

```{r topgenebrain, fig.asp=1.2, fig.wide=TRUE, fig.cap="分配给大脑数据集中前50个最丰富的特征的总计数百分比。对于每个要素，每个条形表示为单个细胞分配给该要素的百分比，而圆圈表示所有细胞的平均值。条形图由每个细胞中表达的特征的总数着色，而圆形根据特征是否标记为控制特征而着色。"}
fontsize <- theme(axis.text=element_text(size=12), axis.title=element_text(size=16))
plotHighestExprs(sce, n=50) + fontsize
```

通过计算所有细胞的平均计数来量化基因丰度 (Figure \@ref(fig:abhistbrain))。
如前所述，UMI计数通常低于reads的计数。

```{r abhistbrain, fig.cap="大脑数据集中所有基因的对数平均计数的直方图。"}
ave.counts <- calcAverage(sce, use_size_factors=FALSE)
hist(log10(ave.counts), breaks=100, main="", col="grey",
    xlab=expression(Log[10]~"average count"))
```

我们将平均计数保存到 `SingleCellExperiment`对象中供以后使用。
我们还删除了平均计数为零的基因，因为这意味着它们不会在任何细胞中表达。

```{r}
rowData(sce)$ave.count <- ave.counts
to.keep <- ave.counts > 0
sce <- sce[to.keep,]
summary(to.keep)
```

```{r echo=FALSE, results='hide'}
gc()
```

# 细胞特异性偏差的正常化

我们使用 `computeSumFactors()` 的功能将内源基因标准化，并进行额外的预聚类步骤 [@lun2016pooling]。
每个聚类中的细胞分别进行标准化，并且size factors被重新调整，以便在聚类之间进行比较。
这避免了假设大多数基因在整个群体中都没有表达差异，只要大多数群集对是没有表达差异就可以了。
然后进行缩放，以确保不同聚类中的细胞的size factors是可比较的。

- 我们使用0.1的平均计数阈值来定义在标准化期间使用的高丰度基因。
这低于默认阈值 `min.mean=1`, 反映了UMI计数通常小于read计数的事实。
- 我们加速聚类的速度通过快速降维并集聚细胞在PCs上。
这是 `BSPARAM=` 参数的使用目的,它指示`quickCluster()`使用PCA^[使用 `r CRANpkg("irlba")`包中的方法。]的近似值算法。
近似值依赖于随机初始化，因此我们需要将随机种子设置为可重复性的-有关更多详细信息，请参见下文。

```{r}
library(BiocSingular)
set.seed(1000)
clusters <- quickCluster(sce, use.ranks=FALSE, BSPARAM=IrlbaParam())
sce <- computeSumFactors(sce, cluster=clusters, min.mean=0.1)
summary(sizeFactors(sce))
```

与416B分析相比，更多的散射可以在每个细胞的总计数和 size factor的趋势间观察到 (Figure \@ref(fig:normplotbrain))。
这与不同类型的细胞之间DE的增加量一致，这折中了文库大小标准化的准确性[@robinson2010scaling]。
相反，the size factors 基于中值比估算并且对于细胞之间的DE的存在是更稳健的。 

```{r normplotbrain, fig.cap="来自汇集的size factors，针对大脑数据集中所有细胞的文库大小绘制。轴以对数刻度显示。"}
plot(sizeFactors(sce), sce$total_counts/1e3, log="xy",
    ylab="Library size (thousands)", xlab="Size factor")
```

我们还计算特定的在顶端聚类的size factors子，如前所述。

```{r}
sce <- computeSpikeFactors(sce, type="Spike", general.use=FALSE)
```

最后，使用适当的size factors计算每个内源基因或加标转录物的标准化对数表达值。

```{r}
sce <- normalize(sce)
```

__Aaron的注释:__

- 只需要粗略的聚类就可以避免将非常不同的细胞类型汇集在一起`computeSumFactors()`之中。
这降低了违反在任何基于基因的缩放归一化期间进行的非DE假设可能性。T
在这一步骤中不需要精确的聚类，因为我们根本不会解释所提及的聚类。
`computeSumFactors()`对于同一聚类中的细胞之间的中等水平的差异表达是很好用的的，因此不需要仔细定义子聚类。
也就是说，每个集群中都需要有足够的细胞用于pooling，这可以通过设置`quickCluster()`中的`min.size=`参数。
- 更旧版本`quickCluster()`执行聚类基于细胞之间的秩相关性。
当前版本 (`use.ranks=FALSE`)使用基于图像化的聚类根据从表达量的对数值获得的主成分。
这比以前更快并且产生更高分辨率的聚类。
尽管如此，可以通过适当设置参数来恢复以前的行为分析，请参考 `?quickCluster` 来获取更多相关信息。

```{r echo=FALSE, results='hide'}
gc()
```

# 建模并消除技术噪音

我们对技术噪音建模通过使用`trendVar()` 函数拟合加标转录物的差异的均值。

```{r}
var.fit <- trendVar(sce, parametric=TRUE, loess.args=list(span=0.4))
var.out <- decomposeVar(sce, var.fit)
```

图 \@ref(fig:hvgplotbrain) 表明趋势与技术产生的差异准确拟合。
技术和总差异也远小于416B数据集中的差异。
这是由于使用了UMI，它降低了由可变PCR扩增引起的噪音 [@islam2014quantitative]。
此外，加入物的趋势始终低于内源基因的差异。
这反映了不同类型细胞中基因表达的异质性。

```{r hvgplotbrain, fig.cap="标准化的对数表达值相对于每个基因的平均值的变化，在除去性别影响后在大脑数据集中的所有细胞上计算。蓝线表示加标转录本的技术差异的平均趋势（也突出显示为红点）。"}
plot(var.out$mean, var.out$total, pch=16, cex=0.6, xlab="Mean log-expression", 
    ylab="Variance of log-expression")
points(var.out$mean[isSpike(sce)], var.out$total[isSpike(sce)], col="red", pch=16)
curve(var.fit$trend(x), col="dodgerblue", add=TRUE, lwd=2)
```

我们检查具有最大生物成分的基因的表达值的分布，以确保它们不是由异常值引起的 (Figure \@ref(fig:hvgvioplotbrain)).
为了可视化大量的细胞，需要对参数进行一些调整。

```{r hvgvioplotbrain, fig.cap="大脑数据集中前10个HVG的归一化对数表达值的小提琴图。对于每个基因，每个点代表单个细胞的对数表达值。"}
chosen.genes <- order(var.out$bio, decreasing=TRUE)[1:10]
plotExpression(sce, rownames(var.out)[chosen.genes], 
    point_alpha=0.05, jitter_type="jitter") + fontsize
```

最后，我们使用PCA对表达l量值进行去噪，为每个已去除技术噪声的细胞生成一组坐标。
设置`denoisePCA()`中的`BSPARAM=IrlbaParam()`，会执行近似奇异值分离法(SVD)，通过使用到`r CRANpkg("irlba")`包中的方法。
这比大型数据集上的精确算法快得多，而且没有损失太多的准确度。
近似算法涉及随机初始化，因此我们设置种子值以保证再现性。

```{r}
set.seed(1000)
sce <- denoisePCA(sce, technical=var.fit$trend, BSPARAM=IrlbaParam())
ncol(reducedDim(sce, "PCA"))
```

**Aaron的注释:**

- 理论上，我们应该暂时保留每个细胞的板的起源。
然而，每个平板上只有20-40个细胞，并且种群也是高度异质的。
这意味着我们不能假设每个板上的采样细胞类型的分布是相同的。
因此，为避免消除潜在的生物学问题，我们不会暂且保留分析中的任何因素。
- 要保留`denoisePCA()`中的的PC的上限，由`max.rank=`参数设定。
较高的`max.rank`可能更适合含有极度差异的群体，尽管降低维度默认设置t已经可以令人满意了。

```{r, echo=FALSE, results='hide', message=FALSE}
gc()
```

# 降低维数的数据探索

我们对去噪的PC进行降维，以检查是否存在子结构。
细胞在 _t_-SNE 图 [@van2008visualizing] in Figure \@ref(fig:tsneplotbrain)中分类成明显的不同聚类，这些聚类对应于不同的亚群。
这与脑细胞群体中存在多种细胞类型一致。
我们增加了混乱度，以牺牲局部比例尺为代价，以便维持整体结构的可视化。

```{r tsneplotbrain, fig.cap="从大脑数据集的去噪PC构建的_t_-SNE 图。 每个点代表一个细胞，并根据其表达着色 _Neurod6_ (左) or _Mog_ (右)。", fig.width=12, fig.asp=0.5}
set.seed(1000)
sce <- runTSNE(sce, use_dimred="PCA", perplexity=50)
tsne1 <- plotTSNE(sce, colour_by="Neurod6") + fontsize
tsne2 <- plotTSNE(sce, colour_by="Mog") + fontsize
multiplot(tsne1, tsne2, cols=2)
```

PCA图在将细胞分离成许多不同的聚类时效果较差 (Figure \@ref(fig:pcaplotbrain))。
这是因为前两个PC是由特定子群体之间的强烈差异导致的，这降低了一些其它子群体之间更微妙差异的识别度。
尽管如此，仍然可以看到一些子结构的差异。

```{r pcaplotbrain, fig.cap="PCA plots constructed from the denoised PCs of the brain dataset. Each point represents a cell and is coloured according to its expression of the _Neurod6_ (left) or _Mog_ (right).", fig.width=12, fig.asp=0.5}
pca1 <- plotReducedDim(sce, use_dimred="PCA", colour_by="Neurod6") + fontsize
pca2 <- plotReducedDim(sce, use_dimred="PCA", colour_by="Mog") + fontsize
multiplot(pca1, pca2, cols=2)
```

对于这两种方法，我们根据特定基因的表达对每个细胞着色。
这是一种有用的策略，用于可视化整个低维空间中表达量的变化。
如果所选基因是特定细胞类型的已知标记，它还可用于表征每个聚类。
例如， _Mog_ 可用于识别对应于少突胶质细胞的聚类。

```{r echo=FALSE, results='hide'}
gc()
```

# 将细胞聚类成假定的亚群

## 使用基于图形的聚类

减小的维度坐标用于将细胞聚类成推定的亚群。
我们通过构建共享最近邻图 [@xu2015identification]来实现,其中细胞是节点，并且在共享最近相邻的细胞之间形成边。
然后使用`r CRANpkg("igraph")`包中的方法将聚类定义为此图中高度相连的细胞社群。
这比使用成对距离矩阵形成大量细胞的分层聚类的方法更有效。

```{r}
snn.gr <- buildSNNGraph(sce, use.dimred="PCA")
cluster.out <- igraph::cluster_walktrap(snn.gr)
my.clusters <- cluster.out$membership
table(my.clusters)
```

我们通过 _t_-SNE图可视化所有细胞聚类的分布情况 \@ref(fig:tsneclusterbrain)。
通常将相邻细胞分配给相同的聚类，同时也证明了整个聚类的过程是正确的。

```{r tsneclusterbrain, message=FALSE, fig.cap="大脑数据集的去噪PC的_t_-SNE 图。每个点代表一个单元格，并根据其指定的聚类标识进行着色。"}
sce$cluster <- factor(my.clusters)
plotTSNE(sce, colour_by="cluster") + fontsize
```

```{r echo=FALSE, results='hide'}
gc()
```

另一种方法是使用基于图形的可视化，例如力导向布局 (Figure \@ref(fig:fdlbrain))。
这方法吸引关联性很强，因为它们直接表示聚类期间的相互关系。
但是，对于大型图形，收敛趋于缓慢，因此需要使用`niter=`参数以确保结果的稳定性。

```{r fdlbrain, message=FALSE, fig.cap="大脑数据集的共享最近邻图的强制定向布局。每个点代表一个细胞，并根据其指定的聚类标识进行着色。"}
set.seed(2000)
reducedDim(sce, "force") <- igraph::layout_with_fr(snn.gr, niter=5000)
plotReducedDim(sce, colour_by="cluster", use_dimred="force")
```

非常异构的数据集可能会在第一轮聚类中产生一些大的聚类。
这是有用的仅使用每个初始聚类的细胞重复构建差异模型，去燥和聚类。
这可以通过构建子集化`sce`基于特定水平的`my.clusters`，并重新应用相关的函数在子集上。
这样做可能集中于在初始聚类内，已被定义为异质性的不同基因集，而不是那些被定义为初始聚类之间差异基因。
这将允许以更高的识别率去探索每个聚类内的精结构。
但是，为简单起见，我们将仅使用与此工作流程中的已明确子群体相对应的广泛聚类。

**Aaron的注释:**

- `r CRANpkg("igraph")`包中提供了许多不同的聚类方法。.
我们发现Walktrap算法通常是一个很好的默认选择[@yang2016comparative]，但鼓励用户尝试不同的算法。
- 减少近邻数量`buildSNNGraph`中的 `k`，将降低图形的连通性。
这通常会导致形成较小的聚类[@xu2015identification], 如果需要更高的识别度，这可能是理想的做法。
- 请注意，我们不运行`library(igraph)`, 而是使用`igraph::` 从包中提取方法。
这是因为 `r CRANpkg("igraph")`包含了 `normalize`的方法，他将会覆盖`r Biocpkg("scater")`的对应物, 导致一些不寻常的错误。

## 评估基于图的聚类232323232323

模块化得分制为community检查方法提供了全局测量聚类情况的表现。
简而言之，它将聚类内边缘的数量与随机边缘的空模型下的预期数量进行比较。
高模块性分数（接近最大值1）表示检测到的聚类富集内部边缘，聚类之间的边缘相对较少。

```{r}
igraph::modularity(cluster.out)
```

我们通过检查每对聚类的边缘的总比重来进一步研究聚类。
对于每对边缘，将观察到的总比重与空模型下的预期总比重进行比较，类似于模块化计算。
大多数聚类包含的内部链接多于预期 (Figure \@ref(fig:heatmodbrain)),而聚类之间的链接少于预期。
这表明我们成功地将细胞聚类成高度连接的社区群。

```{r heatmodbrain, fig.cap="相对于在随机链接的空模型下预期的总权重，相同聚类或不同聚类中的节点之间的总权重的log 10的比率的热图。"}
mod.out <- clusterModularity(snn.gr, my.clusters, get.values=TRUE)
ratio <- mod.out$observed/mod.out$expected
lratio <- log10(ratio + 1)

library(pheatmap)
pheatmap(lratio, cluster_rows=FALSE, cluster_cols=FALSE, 
    color=colorRampPalette(c("white", "blue"))(100))
```

为了总结聚类之间的关系，我们使用观察到的和预期的总权重的比率来构建跨聚类的图。
可以使用力导向布局来可视化基于群聚类的图，以识别高度互连的“聚类群”。
这类似于@wolf2017graph 提出的“图形抽象”策略.

```{r graphbrain, fig.cap="力导向布局，显示基于不同聚类中节点之间观察到的预期总重量的比率的聚类之间的关系。一对聚类之间的边缘的厚度与相应的比例成比例"}
cluster.gr <- igraph::graph_from_adjacency_matrix(ratio, 
    mode="undirected", weighted=TRUE, diag=FALSE)
plot(cluster.gr, edge.width=igraph::E(cluster.gr)$weight*10)  
```

**Aaron的注释:**

- 我们不使用轮廓系数来评估大型数据集的聚类。
这是因为 `cluster::silhouette` 需要构建距离矩阵，当涉及许多细胞时这可能是不可行的。
- 从技术上讲，模块性分数制是通过从预期的总权重中减去观察到的。
我们使用该比率，因为它的值保证是正的，并且没有因每个聚类中的细胞数量的差异而，表现出幅度差异。.

# 检测亚群之间的标记基因

```{r, echo=FALSE, results="hide"}
# Hidden variables for use in text or hidden chunks,
# to avoid the need for manual changes.
chosen.inter.cluster <- 4
chosen.inter.other <- 11
```

我们使用该 `findMarkers` 函数和`direction="up"`选项去识别每个聚类的上调标记基因。
如上所述，我们重点关注于上调基因，因为这些基因可以快速提供异质群体中细胞类型的有效鉴定。
我们检查了这个 `r chosen.inter.cluster`聚类的表, 在这个表中报告了聚类`r chosen.inter.cluster`和其它聚类对数倍的变化。
每个聚类具有相同的输出，以便识别区分聚类中的基因。

```{r, echo=FALSE, results="hide"}
old.digits <- options()$digits
options(digits=3)
```

```{r}
markers <- findMarkers(sce, my.clusters, direction="up")
marker.set <- markers[["4"]]
head(marker.set[,1:8], 10) # only first 8 columns, for brevity
```

```{r, echo=FALSE, results="hide"}
# Checking the cluster is what we wanted, along with its related cluster.
other.inter <- chosen.inter.other - 1
gad1 <- sapply(marker.set["Gad1",-(1:3)], sign)
stopifnot(gad1[other.inter]==-1)
stopifnot(all(gad1[-other.inter]==1))

gad2 <- sapply(marker.set["Gad2",-(1:3)], sign)
stopifnot(gad2[other.inter]==-1)
stopifnot(all(gad2[-other.inter]==1))

stopifnot(all(sapply(marker.set["Synpr",-(1:3)], sign)==1))

options(digits=old.digits)
```

图 \@ref(fig:heatmapmarkerbrain) 表明与一些其它聚类相比，聚类 `r chosen.inter.cluster`含有与其它聚类对比的大多数具有比较大表达差异的顶端标记。
我们可以使用这些标记在具有独立细胞群的验证研究中鉴定聚类`r chosen.inter.cluster` 中的细胞。
快速观察聚类表明聚类 `r chosen.inter.cluster`代表基于 *Gad1* 和 *Slc6a1*的中间神经元 [@zeng2012largescale],
与在聚类`r chosen.inter.other`中密切相关的细胞不同，因为*Synpr* 高度表达。

```{r heatmapmarkerbrain, fig.wide=TRUE, fig.cap=sprintf("大脑数据集中聚类`chosen.inter.cluster`的顶部标记集的平均中心和标准化对数表达值的热图。列颜色表示每个细胞分配到的聚类，如图例所示。", chosen.inter.cluster)}
top.markers <- rownames(marker.set)[marker.set$Top <= 10]
plotHeatmap(sce, features=top.markers, columns=order(my.clusters),
    colour_columns_by="cluster", cluster_cols=FALSE, 
    center=TRUE, symmetric=TRUE, zlim=c(-5, 5))
```

另一种可视化方法是直接将对数倍变化绘制到所有其它聚类(Figure \@ref(fig:heatmaplfcbrain))。
这更简洁，在涉及包含不同数量细胞的多个聚类的情况下非常有用。.

```{r heatmaplfcbrain, fig.asp=1.5, fig.cap=sprintf("与大脑数据集中的每个其它聚类相比，聚类`chosen.inter.cluster`的顶部标记集的表达式中对数倍变化的热图。" )}
logFCs <- as.matrix(marker.set[1:50,-(1:3)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))

library(pheatmap)
max.lfc <- max(abs(range(logFCs)))
pheatmap(logFCs, breaks=seq(-5, 5, length.out=101))
```

我们保存候选标记基因列表以供进一步检查，使用压缩的方法来减小文件大小。

```{r}
gzout <- gzfile("brain_marker_1.tsv.gz", open="wb")
write.table(marker.set, file=gzout, sep="\t", quote=FALSE, col.names=NA)
close(gzout)
```

**Aaron的注释:**

- 该 `overlapExprs()`函数也可用于总结集群之间的差异。
更详细的的讨论 `r simpleSingleCell:::.link("de", "Using the Wilcoxon rank sum test", "在这里")`.

# 结束语

完成基本分析后，我们将`SingleCellExperiment` 对象及其关联数据保存到文件中。
这非常重要，因为大脑数据集非常大。
如果要进行进一步的分析，则必须重复上述所有的预处理步骤是不方便的。

```{r}
saveRDS(file="brain_data.rds", sce)
```

```{r, echo=FALSE, results='hide'}
gc()
```

All software packages used in this workflow are publicly available from the Comprehensive R Archive Network (https://cran.r-project.org) or the Bioconductor project (http://bioconductor.org).
The specific version numbers of the packages used are shown below, along with the version of the R installation.

```{r}
sessionInfo()
```

# References

